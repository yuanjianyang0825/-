"""
å…‰è°±å…±ç„¦ä¸‰ç»´é‡æ„ç³»ç»Ÿ - ç²¾ç¡®å…‰æ–‘åŒ¹é…ç‰ˆ
- Xæ–¹å‘åŒ¹é…å®¹å·®: Â±3åƒç´ 
- Yæ–¹å‘åŒ¹é…å®¹å·®: -90 ~ 0åƒç´  (é«˜åº¦å¢åŠ æ—¶å…‰æ–‘ä¸Šç§»)
- å®‰å…¨æ—‹è½¬: resize=True ä¿ç•™æ‰€æœ‰è¾¹ç¼˜å…‰æ–‘
- è¾“å‡º: 3Dç‚¹äº‘ + é«˜åº¦çƒ­åŠ›å›¾ + åŒ¹é…è´¨é‡æŠ¥å‘Š
"""

import os
import numpy as np
import imageio.v2 as imageio
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from skimage.transform import rotate
from skimage.feature import peak_local_max
from scipy.ndimage import center_of_mass
from scipy.optimize import curve_fit
from numpy.polynomial import Polynomial
import warnings
warnings.filterwarnings('ignore')
plt.rcParams['font.sans-serif'] = ['SimHei', 'Microsoft YaHei', 'DejaVu Sans']  # ä¼˜å…ˆä½¿ç”¨é»‘ä½“/å¾®è½¯é›…é»‘
plt.rcParams['axes.unicode_minus'] = False  # è§£å†³è´Ÿå·æ˜¾ç¤ºä¸ºæ–¹æ¡†çš„é—®é¢˜
# ==================== é…ç½®åŒº ====================
# æ ‡å®šæ•°æ®è·¯å¾„ï¼ˆå¿…é¡»ä½¿ç”¨å®‰å…¨æ—‹è½¬æ ‡å®šç”Ÿæˆçš„æ–‡ä»¶ï¼‰
calib_file = r"C:\Users\A\Desktop\biaoding\calib_table_full_retention.npz"

# è¢«æµ‹ç‰©å›¾åƒè·¯å¾„
sample_img_path = r"C:\Users\A\Desktop\biaoding\2.bmp"  # âœ… è¯·ä¿®æ”¹ä¸ºå®é™…è·¯å¾„

# å…‰æ–‘åŒ¹é…å‚æ•°ï¼ˆæ ¸å¿ƒï¼ä¸¥æ ¼éµå¾ªæ‚¨çš„è¦æ±‚ï¼‰
x_tolerance = 2      # Xæ–¹å‘å®¹å¿åº¦ Â±3åƒç´ 
y_min_offset = -85.0   # Yæ–¹å‘æœ€å°åç§»ï¼ˆè´Ÿå€¼è¡¨ç¤ºå‘ä¸Šï¼‰
y_max_offset = 0.0     # Yæ–¹å‘æœ€å¤§åç§»ï¼ˆ0è¡¨ç¤ºä¸å…è®¸å‘ä¸‹åç§»ï¼‰

# é‡æ„å‚æ•°
roi_radius = 9          # ROIåŠå¾„ï¼ˆä¸æ ‡å®šä¸€è‡´ï¼‰
gauss_fallback = True   # é«˜æ–¯æ‹Ÿåˆå¤±è´¥å›é€€åˆ°è´¨å¿ƒ
pixel_size_um = 3.45    # åƒç´ ç‰©ç†å°ºå¯¸ (å¾®ç±³) - è¯·æ ¹æ®æ‚¨çš„ç›¸æœºä¿®æ”¹
save_results = True     # æ˜¯å¦ä¿å­˜ç»“æœ
# =============================================

# ---------- é«˜æ–¯æ‹Ÿåˆå‡½æ•°ï¼ˆä¸æ ‡å®šä¸€è‡´ï¼‰----------
def gauss_1d(x, A, mu, sigma, B):
    return A * np.exp(-0.5 * ((x - mu) / sigma) ** 2) + B

def fit_gauss_center(line):
    x = np.arange(len(line), dtype=float)
    try:
        mu0 = np.sum(x * line) / np.sum(line)
        A0 = line.max() - line.min()
        B0 = line.min()
        p0 = [A0, mu0, 2.0, B0]
        popt, _ = curve_fit(gauss_1d, x, line, p0=p0, maxfev=1000)
        return popt[1]
    except (RuntimeError, ValueError):
        if gauss_fallback:
            return center_of_mass(line)[0]
        else:
            return np.nan

# ---------- å®‰å…¨æ—‹è½¬å‡½æ•°ï¼ˆä¸æ ‡å®šä¸€è‡´ï¼‰----------
def compute_rotated_size(h, w, angle_deg):
    theta = np.deg2rad(abs(angle_deg))
    new_w = int(np.ceil(w * np.abs(np.cos(theta)) + h * np.abs(np.sin(theta))))
    new_h = int(np.ceil(w * np.abs(np.sin(theta)) + h * np.abs(np.cos(theta))))
    return new_h, new_w

def rotate_image_safe(gray_img, angle_deg, out_shape):
    rot = rotate(
        gray_img,
        angle=angle_deg,
        resize=True,
        mode='constant',
        cval=0,
        preserve_range=True,
        order=1
    ).astype(np.float32)
    
    # å°ºå¯¸æ ¡å‡†ï¼ˆåº”å¯¹æå°çš„æµ®ç‚¹èˆå…¥å·®å¼‚ï¼‰
    if rot.shape != out_shape:
        pad_h = out_shape[0] - rot.shape[0]
        pad_w = out_shape[1] - rot.shape[1]
        rot = np.pad(
            rot,
            ((max(0, pad_h//2), max(0, pad_h-pad_h//2)), 
             (max(0, pad_w//2), max(0, pad_w-pad_w//2))),
            mode='constant',
            constant_values=0
        )[:out_shape[0], :out_shape[1]]
    return rot

# ==================== ä¸»æµç¨‹ ====================

print("="*70)
print("ğŸ”¬ å…‰è°±å…±ç„¦ä¸‰ç»´é‡æ„ç³»ç»Ÿ - ç²¾ç¡®å…‰æ–‘åŒ¹é…ç‰ˆ")
print("="*70)

# 1. åŠ è½½æ ‡å®šæ•°æ®ï¼ˆå«æ—‹è½¬å‚æ•°ï¼‰
print("\n[1/6] æ­£åœ¨åŠ è½½æ ‡å®šæ•°æ®...")
if not os.path.exists(calib_file):
    raise FileNotFoundError(f"âŒ æ ‡å®šæ–‡ä»¶ä¸å­˜åœ¨: {calib_file}\n"
                          f"   è¯·å…ˆè¿è¡Œå®‰å…¨æ—‹è½¬æ ‡å®šä»£ç ç”Ÿæˆ calib_table_full_retention.npz")

calib_data = np.load(calib_file, allow_pickle=True)
x0_calib = calib_data['x0']      # æ ‡å®šå‚è€ƒå¸§äºšåƒç´ Xåæ ‡
y0_calib = calib_data['y0']      # æ ‡å®šå‚è€ƒå¸§äºšåƒç´ Yåæ ‡
coeffs = calib_data['coeffs']    # å¤šé¡¹å¼ç³»æ•° (object array)
orders = calib_data['orders']    # å¤šé¡¹å¼é˜¶æ•°
heights_mm = calib_data['heights']  # æ ‡å®šé«˜åº¦åºåˆ—
peaks = calib_data['peaks']      # æ‰€æœ‰å¸§çš„Yä½ç½®
N = int(calib_data['N'])
rotation_angle = float(calib_data['rotation_angle'])
rotated_shape = tuple(calib_data['rotated_shape'])

print(f"   â€¢ æ ‡å®šå…‰æ–‘æ€»æ•°: {N}")
print(f"   â€¢ æ—‹è½¬è§’åº¦: {abs(rotation_angle)}Â° é¡ºæ—¶é’ˆ")
print(f"   â€¢ æ—‹è½¬åå›¾åƒå°ºå¯¸: {rotated_shape[0]} Ã— {rotated_shape[1]} åƒç´ ")
print(f"   â€¢ åŒ¹é…å‚æ•°: XÂ±{x_tolerance}px, Y[{y_min_offset}, {y_max_offset}]px")

# 2. åŠ è½½å¹¶æ—‹è½¬æ ·å“å›¾åƒï¼ˆä¸æ ‡å®šç›¸åŒé¢„å¤„ç†ï¼‰
print("\n[2/6] æ­£åœ¨åŠ è½½å¹¶æ—‹è½¬æ ·å“å›¾åƒ...")
if not os.path.exists(sample_img_path):
    raise FileNotFoundError(f"âŒ æ ·å“å›¾åƒä¸å­˜åœ¨: {sample_img_path}")

# è¯»å–å›¾åƒ
sample_img = imageio.imread(sample_img_path)
if sample_img.ndim == 3:
    gray_sample = sample_img[:, :, 0].astype(np.float32)  # å–Ré€šé“
else:
    gray_sample = sample_img.astype(np.float32)

# åº”ç”¨ä¸æ ‡å®šå®Œå…¨ç›¸åŒçš„æ—‹è½¬
rotated_sample = rotate_image_safe(gray_sample, rotation_angle, rotated_shape)
H, W = rotated_shape
print(f"   â€¢ åŸå§‹å°ºå¯¸: {gray_sample.shape} â†’ æ—‹è½¬å: {rotated_sample.shape}")

# 3. æ ·å“å…‰æ–‘æ£€æµ‹ä¸äºšåƒç´ å®šä½
print("\n[3/6] æ­£åœ¨æ£€æµ‹æ ·å“å…‰æ–‘å¹¶äºšåƒç´ å®šä½...")
sample_peaks = peak_local_max(
    rotated_sample,
    min_distance=20,
    threshold_abs=50
)
print(f"   â€¢ ç²—æ£€æµ‹å…‰æ–‘æ•°: {len(sample_peaks)}")

# äºšåƒç´ ç²¾ç¡®å®šä½
sample_subpixel = np.full((len(sample_peaks), 2), np.nan, dtype=np.float32)
for i, (y_int, x_int) in enumerate(sample_peaks):
    # æå–ROI
    y1 = max(int(y_int) - roi_radius, 0)
    y2 = min(int(y_int) + roi_radius + 1, H)
    x1 = max(int(x_int) - roi_radius, 0)
    x2 = min(int(x_int) + roi_radius + 1, W)
    
    roi = rotated_sample[y1:y2, x1:x2]
    if roi.size == 0 or roi.sum() < 1e-3:
        continue
    
    # äºšåƒç´ å®šä½
    proj_x = roi.sum(axis=0)  # Xæ–¹å‘åˆ†å¸ƒ
    proj_y = roi.sum(axis=1)  # Yæ–¹å‘åˆ†å¸ƒ
    
    dx = fit_gauss_center(proj_x)
    dy = fit_gauss_center(proj_y)
    
    if not np.isnan(dx) and not np.isnan(dy):
        sample_subpixel[i] = [x1 + dx, y1 + dy]

# è¿‡æ»¤æ— æ•ˆç‚¹
valid_mask = ~np.isnan(sample_subpixel[:, 0])
sample_subpixel_valid = sample_subpixel[valid_mask]
print(f"   â€¢ æœ‰æ•ˆäºšåƒç´ å…‰æ–‘: {len(sample_subpixel_valid)}")

# 4. ç²¾ç¡®å…‰æ–‘åŒ¹é…ï¼ˆæ ¸å¿ƒæ­¥éª¤ - ä¸¥æ ¼éµå¾ªæ‚¨çš„è¦æ±‚ï¼‰
print("\n[4/6] æ­£åœ¨æ‰§è¡Œç²¾ç¡®å…‰æ–‘åŒ¹é…...")
print(f"   åŒ¹é…ç­–ç•¥: Xæ–¹å‘Â±{x_tolerance}px, Yæ–¹å‘[{y_min_offset}, {y_max_offset}]px")
matches = -np.ones(len(sample_subpixel_valid), dtype=int)  # -1è¡¨ç¤ºæœªåŒ¹é…
match_distances = np.full(len(sample_subpixel_valid), np.inf)  # è®°å½•åŒ¹é…è·ç¦»

for i, (x_sample, y_sample) in enumerate(sample_subpixel_valid):
    # è®¡ç®—ä¸æ‰€æœ‰æ ‡å®šå…‰æ–‘çš„åç§»é‡
    dx = x_sample - x0_calib
    dy = y_sample - y0_calib
    
    # åº”ç”¨åŒ¹é…æ¡ä»¶ï¼ˆæ‚¨çš„æ ¸å¿ƒè¦æ±‚ï¼‰
    valid_candidates = (
        (np.abs(dx) <= x_tolerance) & 
        (dy >= y_min_offset) & 
        (dy <= y_max_offset)
    )
    
    if not np.any(valid_candidates):
        continue
    
    # åœ¨æ»¡è¶³æ¡ä»¶çš„å€™é€‰ä¸­ï¼Œé€‰æ‹©Yæ–¹å‘æœ€æ¥è¿‘çš„ï¼ˆæœ€å°|dy|ï¼‰
    candidate_indices = np.where(valid_candidates)[0]
    dy_candidates = dy[candidate_indices]
    best_idx = candidate_indices[np.argmin(np.abs(dy_candidates))]
    
    matches[i] = best_idx
    match_distances[i] = np.abs(dy[best_idx])

# ç»Ÿè®¡åŒ¹é…ç»“æœ
num_matched = np.sum(matches >= 0)
match_rate = num_matched / N * 100
print(f"   â€¢ æˆåŠŸåŒ¹é…å…‰æ–‘: {num_matched} / {N} ({match_rate:.1f}%)")
print(f"   â€¢ æœªåŒ¹é…å…‰æ–‘: {N - num_matched}")

# 5. é«˜åº¦åè§£ï¼ˆä½¿ç”¨æ ‡å®šå¤šé¡¹å¼ï¼‰
print("\n[5/6] æ­£åœ¨åè§£è¡¨é¢é«˜åº¦...")
z_heights = np.full(len(matches), np.nan, dtype=np.float32)

for i, match_idx in enumerate(matches):
    if match_idx < 0:
        continue
    
    # è·å–å½“å‰æ ·å“å…‰æ–‘çš„Yåæ ‡
    y_measured = sample_subpixel_valid[i, 1]
    
    # ä½¿ç”¨å¯¹åº”çš„æ ‡å®šå¤šé¡¹å¼åè§£é«˜åº¦
    # å¤šé¡¹å¼: y = c0 + c1*z + c2*z^2 + ... 
    coef = coeffs[match_idx]  # ä½æ¬¡â†’é«˜æ¬¡: [c0, c1, c2, ...]
    deg = orders[match_idx]
    
    # æ„å»ºå¤šé¡¹å¼å¯¹è±¡
    p = Polynomial(coef[::-1])  # Polynomialè¦æ±‚é«˜æ¬¡â†’ä½æ¬¡
    
    # æ•°å€¼æœç´¢æ±‚è§£ z = f^{-1}(y)
    # åœ¨æ ‡å®šé‡ç¨‹å†…å¯†é›†é‡‡æ ·æœç´¢
    z_search = np.linspace(heights_mm.min(), heights_mm.max(), 5000)
    y_pred = p(z_search)
    residuals = np.abs(y_pred - y_measured)
    best_z_idx = np.argmin(residuals)
    z_est = z_search[best_z_idx]
    
    # ç‰©ç†çº¦æŸæ£€æŸ¥
    if 0 <= z_est <= 2.5:
        z_heights[i] = z_est
    else:
        print(f"   âš ï¸  å…‰æ–‘#{i} åè§£é«˜åº¦ {z_est:.4f}mm è¶…å‡ºé‡ç¨‹ï¼Œå·²ä¸¢å¼ƒ")

# æå–æœ‰æ•ˆç»“æœ
valid_z_mask = ~np.isnan(z_heights)
x_valid = sample_subpixel_valid[valid_z_mask, 0]
y_valid = sample_subpixel_valid[valid_z_mask, 1]
z_valid = z_heights[valid_z_mask]
match_indices = matches[valid_z_mask]

print(f"   â€¢ æœ‰æ•ˆé«˜åº¦ç‚¹: {len(z_valid)}")
if len(z_valid) > 0:
    print(f"   â€¢ é«˜åº¦èŒƒå›´: {z_valid.min():.4f} ~ {z_valid.max():.4f} mm")
    print(f"   â€¢ å¹³å‡é«˜åº¦: {z_valid.mean():.4f} Â± {z_valid.std():.4f} mm")

# 6. åæ ‡è½¬æ¢ä¸3Dç‚¹äº‘ç”Ÿæˆ
print("\n[6/6] æ­£åœ¨ç”Ÿæˆ3Dç‚¹äº‘...")
if len(z_valid) == 0:
    raise RuntimeError("âŒ æœªèƒ½ç”Ÿæˆæœ‰æ•ˆç‚¹äº‘ï¼è¯·æ£€æŸ¥åŒ¹é…å‚æ•°æˆ–å›¾åƒè´¨é‡")

# åƒç´ åæ ‡ â†’ ç‰©ç†åæ ‡ (mm)
pixel_size_mm = pixel_size_um / 1000.0  # å¾®ç±³è½¬æ¯«ç±³
x_phys = x_valid * pixel_size_mm
y_phys = (H - y_valid) * pixel_size_mm  # Yè½´ç¿»è½¬ï¼ˆå›¾åƒåŸç‚¹åœ¨ä¸Šï¼‰
z_phys = z_valid  # é«˜åº¦å·²æ˜¯mm

# æ„å»ºç‚¹äº‘
points_3d = np.column_stack([x_phys, y_phys, z_phys])

# 7. å¯è§†åŒ–
print("\nğŸ“Š ç”Ÿæˆå¯è§†åŒ–ç»“æœ...")
fig = plt.figure(figsize=(16, 9))

# å­å›¾1: æ—‹è½¬åæ ·å“å›¾åƒ + åŒ¹é…å…‰æ–‘æ ‡è®°
ax1 = fig.add_subplot(2, 3, 1)
ax1.imshow(rotated_sample, cmap='gray')
ax1.set_title('æ—‹è½¬åæ ·å“å›¾åƒ', fontsize=11, fontweight='bold')
ax1.axis('off')

# å­å›¾2: åŒ¹é…ç»“æœå¯è§†åŒ–ï¼ˆæ ‡å®šå…‰æ–‘ vs æ ·å“å…‰æ–‘ï¼‰
ax2 = fig.add_subplot(2, 3, 2)
ax2.imshow(rotated_sample, cmap='gray', alpha=0.6)
# ç»˜åˆ¶æ ‡å®šå…‰æ–‘ä½ç½®ï¼ˆè“è‰²åå­—ï¼‰
ax2.scatter(x0_calib, y0_calib, c='blue', s=20, marker='x', label='æ ‡å®šå…‰æ–‘', alpha=0.7)
# ç»˜åˆ¶æˆåŠŸåŒ¹é…çš„æ ·å“å…‰æ–‘ï¼ˆçº¢è‰²åœ†åœˆï¼‰
if num_matched > 0:
    matched_sample = sample_subpixel_valid[matches >= 0]
    ax2.scatter(matched_sample[:, 0], matched_sample[:, 1], 
               c='red', s=30, marker='o', facecolors='none', 
               label=f'åŒ¹é…å…‰æ–‘ ({num_matched})', linewidth=1.5)
ax2.set_title(f'å…‰æ–‘åŒ¹é…ç»“æœ\nXÂ±{x_tolerance}px, Y[{y_min_offset},{y_max_offset}]px', 
             fontsize=11, fontweight='bold')
ax2.legend(loc='upper right', fontsize=8)
ax2.axis('off')

# å­å›¾3: é«˜åº¦çƒ­åŠ›å›¾ï¼ˆ2Dï¼‰
ax3 = fig.add_subplot(2, 3, 3)
sc = ax3.scatter(x_valid, H - y_valid, c=z_valid, cmap='jet', s=30, 
                edgecolors='k', linewidth=0.3, alpha=0.8)
ax3.set_title('è¡¨é¢é«˜åº¦çƒ­åŠ›å›¾ (ä¿¯è§†)', fontsize=11, fontweight='bold')
ax3.set_xlabel('X (åƒç´ )')
ax3.set_ylabel('Y (åƒç´ )')
ax3.set_aspect('equal')
plt.colorbar(sc, ax=ax3, label='Height (mm)')

# å­å›¾4: 3Dç‚¹äº‘ï¼ˆæ•£ç‚¹ï¼‰
ax4 = fig.add_subplot(2, 3, 4, projection='3d')
ax4.scatter(points_3d[:, 0], points_3d[:, 1], points_3d[:, 2],
           c=points_3d[:, 2], cmap='jet', s=12, alpha=0.9)
ax4.set_title('3Dç‚¹äº‘ (æ•£ç‚¹)', fontsize=11, fontweight='bold')
ax4.set_xlabel('X (mm)')
ax4.set_ylabel('Y (mm)')
ax4.set_zlabel('Z (mm)')
ax4.view_init(elev=30, azim=-60)

# å­å›¾5: é«˜åº¦åˆ†å¸ƒç›´æ–¹å›¾
ax5 = fig.add_subplot(2, 3, 5)
ax5.hist(z_valid, bins=30, color='steelblue', edgecolor='black', alpha=0.85)
ax5.axvline(z_valid.mean(), color='r', linestyle='--', 
           label=f'å‡å€¼: {z_valid.mean():.4f} mm')
ax5.axvline(z_valid.mean() - z_valid.std(), color='g', linestyle=':', alpha=0.7)
ax5.axvline(z_valid.mean() + z_valid.std(), color='g', linestyle=':', alpha=0.7,
           label=f'Â±1Ïƒ ({z_valid.std():.4f} mm)')
ax5.set_title('é«˜åº¦åˆ†å¸ƒç›´æ–¹å›¾', fontsize=11, fontweight='bold')
ax5.set_xlabel('Height (mm)')
ax5.set_ylabel('Frequency')
ax5.legend(fontsize=9)
ax5.grid(True, alpha=0.3)

# å­å›¾6: åŒ¹é…è´¨é‡åˆ†æ
ax6 = fig.add_subplot(2, 3, 6)
if num_matched > 0:
    matched_dists = match_distances[matches >= 0]
    ax6.hist(matched_dists, bins=20, color='coral', edgecolor='black', alpha=0.8)
    ax6.axvline(np.mean(matched_dists), color='r', linestyle='--',
               label=f'å¹³å‡Yåç§»: {np.mean(matched_dists):.2f}px')
    ax6.set_title('åŒ¹é…Yæ–¹å‘åç§»åˆ†å¸ƒ', fontsize=11, fontweight='bold')
    ax6.set_xlabel('Yæ–¹å‘åç§»é‡ (åƒç´ )')
    ax6.set_ylabel('Frequency')
    ax6.legend(fontsize=9)
    ax6.grid(True, alpha=0.3)
else:
    ax6.text(0.5, 0.5, 'æ— åŒ¹é…å…‰æ–‘', ha='center', va='center', 
            fontsize=14, color='red', fontweight='bold')
    ax6.set_title('åŒ¹é…è´¨é‡åˆ†æ', fontsize=11, fontweight='bold')

plt.tight_layout()
plt.suptitle('å…‰è°±å…±ç„¦ä¸‰ç»´è¡¨é¢é‡æ„ç»“æœ - ç²¾ç¡®å…‰æ–‘åŒ¹é…ç‰ˆ', 
            fontsize=14, fontweight='bold', y=0.995)
plt.show()

# 8. ä¿å­˜ç»“æœ
if save_results:
    output_dir = os.path.dirname(sample_img_path)
    base_name = os.path.splitext(os.path.basename(sample_img_path))[0]
    
    # ä¿å­˜ç‚¹äº‘ (CSVæ ¼å¼ï¼Œå«ç‰©ç†åæ ‡)
    csv_path = os.path.join(output_dir, f"{base_name}_3d_reconstruction.csv")
    np.savetxt(csv_path, 
              np.column_stack([x_phys, y_phys, z_phys, match_indices]),
              header="x_mm,y_mm,z_mm,calib_spot_index", 
              comments='', delimiter=',', fmt='%.6f')
    print(f"âœ… 3Dç‚¹äº‘å·²ä¿å­˜: {csv_path}")
    
    # ä¿å­˜å¯è§†åŒ–å›¾
    fig_path = os.path.join(output_dir, f"{base_name}_reconstruction.png")
    fig.savefig(fig_path, dpi=150, bbox_inches='tight')
    print(f"âœ… å¯è§†åŒ–ç»“æœå·²ä¿å­˜: {fig_path}")
    
    # ä¿å­˜åŒ¹é…æŠ¥å‘Š
    report_path = os.path.join(output_dir, f"{base_name}_matching_report.txt")
    with open(report_path, 'w', encoding='utf-8') as f:
        f.write("="*60 + "\n")
        f.write("å…‰è°±å…±ç„¦ä¸‰ç»´é‡æ„ - åŒ¹é…è´¨é‡æŠ¥å‘Š\n")
        f.write("="*60 + "\n")
        f.write(f"æ ·å“å›¾åƒ: {sample_img_path}\n")
        f.write(f"æ ‡å®šæ–‡ä»¶: {calib_file}\n")
        f.write(f"æ—‹è½¬è§’åº¦: {abs(rotation_angle)}Â° é¡ºæ—¶é’ˆ\n")
        f.write(f"åŒ¹é…å‚æ•°: XÂ±{x_tolerance}px, Y[{y_min_offset}, {y_max_offset}]px\n")
        f.write("-"*60 + "\n")
        f.write(f"æ ‡å®šå…‰æ–‘æ€»æ•°: {N}\n")
        f.write(f"æ ·å“æ£€æµ‹å…‰æ–‘: {len(sample_subpixel_valid)}\n")
        f.write(f"æˆåŠŸåŒ¹é…å…‰æ–‘: {num_matched} ({match_rate:.1f}%)\n")
        f.write(f"æœ‰æ•ˆé«˜åº¦ç‚¹: {len(z_valid)}\n")
        f.write("-"*60 + "\n")
        if len(z_valid) > 0:
            f.write(f"é«˜åº¦èŒƒå›´: {z_valid.min():.4f} ~ {z_valid.max():.4f} mm\n")
            f.write(f"å¹³å‡é«˜åº¦: {z_valid.mean():.4f} Â± {z_valid.std():.4f} mm\n")
            f.write(f"è¡¨é¢ç²—ç³™åº¦(RMS): {z_valid.std():.4f} mm\n")
        f.write("="*60 + "\n")
    print(f"âœ… åŒ¹é…æŠ¥å‘Šå·²ä¿å­˜: {report_path}")

# 9. æœ€ç»ˆæŠ¥å‘Š
print("\n" + "="*70)
print("âœ… ä¸‰ç»´é‡æ„å®Œæˆï¼")
print("="*70)
print(f"â€¢ åŒ¹é…æˆåŠŸç‡: {num_matched}/{N} ({match_rate:.1f}%)")
print(f"â€¢ æœ‰æ•ˆ3Dç‚¹æ•°: {len(z_valid)}")
if len(z_valid) > 0:
    print(f"â€¢ é«˜åº¦èŒƒå›´: {z_valid.min():.4f} ~ {z_valid.max():.4f} mm")
    print(f"â€¢ è¡¨é¢ç²—ç³™åº¦(RMS): {z_valid.std():.4f} mm")
print(f"â€¢ åƒç´ ç‰©ç†å°ºå¯¸: {pixel_size_um} Î¼m")
print("="*70)

# å¯é€‰ï¼šOpen3Däº¤äº’å¼å¯è§†åŒ–
try:
    import open3d as o3d
    
    pcd = o3d.geometry.PointCloud()
    pcd.points = o3d.utility.Vector3dVector(points_3d)
    
    # æŒ‰é«˜åº¦ç€è‰²
    colors = plt.cm.jet((z_phys - z_phys.min()) / (z_phys.max() - z_phys.min() + 1e-8))[:, :3]
    pcd.colors = o3d.utility.Vector3dVector(colors)
    
    # ä¼°è®¡æ³•çº¿ï¼ˆç”¨äºæ›´å¥½çš„å¯è§†åŒ–ï¼‰
    if len(points_3d) > 30:
        pcd.estimate_normals(search_param=o3d.geometry.KDTreeSearchParamHybrid(radius=0.1, max_nn=30))
    
    # åˆ›å»ºåæ ‡ç³»
    coord_frame = o3d.geometry.TriangleMesh.create_coordinate_frame(size=0.5)
    
    print("\nğŸ”„ æ­£åœ¨å¯åŠ¨Open3Däº¤äº’å¼3Då¯è§†åŒ–...")
    o3d.visualization.draw_geometries([pcd, coord_frame],
                                     window_name="å…‰è°±å…±ç„¦3Dé‡æ„ - äº¤äº’è§†å›¾",
                                     width=1000, height=700,
                                     left=50, top=50)
    print("âœ… Open3Då¯è§†åŒ–çª—å£å·²å…³é—­")
    
except ImportError:
    print("\nâš ï¸  æœªå®‰è£…Open3Dï¼Œè·³è¿‡äº¤äº’å¼3Då¯è§†åŒ–")
    print("   å®‰è£…å‘½ä»¤: pip install open3d")
except Exception as e:
    print(f"\nâš ï¸  Open3Då¯è§†åŒ–å¤±è´¥: {e}")
