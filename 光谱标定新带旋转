# -*- coding: utf-8 -*-
"""
- é‡ç¨‹ï¼š0â€“2.5 mmï¼Œ26 å¼ ç­‰é—´éš”é«˜åº¦å›¾åƒ
- å®Œå…¨å¤ç°å‚è€ƒä»£ç çš„æ—‹è½¬æ–¹å¼ï¼ˆä»¥(0,0)ä¸ºä¸­å¿ƒï¼Œé€†æ—¶é’ˆ-3.05Â°ï¼‰
"""

import os, glob
import numpy as np
import imageio.v2 as imageio
import cv2
from skimage.feature import peak_local_max
from scipy.ndimage import center_of_mass
from scipy.optimize import curve_fit
from numpy.polynomial import Polynomial

# ==================== é…ç½®åŒº ====================
calib_dir = r"C:\Users\A\Desktop\biaoding"
heights_mm = np.linspace(2.5, 0, 26)  # ç¬¬0å¸§=æœ€é«˜é«˜åº¦(2.5mm)
roi_radius = 9
gauss_fallback = True
rotation_angle = -3.05  # å®Œå…¨æŒ‰ç…§å‚è€ƒä»£ç ï¼š-3.05åº¦

# =================================================

# ---------- å®Œå…¨å¤ç°å‚è€ƒä»£ç çš„æ—‹è½¬å‡½æ•° ----------
def rotate_image_like_reference(img):
    """
    å®Œå…¨æŒ‰ç…§å‚è€ƒä»£ç çš„æ–¹å¼è¿›è¡Œæ—‹è½¬ï¼š
    - æ·»åŠ 1000åƒç´ è¾¹æ¡†
    - ä»¥(0,0)ä¸ºä¸­å¿ƒ
    - æ—‹è½¬è§’åº¦ä¸º rotation_angle (-3.05)
    """
    # ç¡®ä¿è¾“å…¥æ˜¯ uint8 æ ¼å¼ï¼ˆOpenCV è¦æ±‚ï¼‰
    if img.dtype != np.uint8:
        img_uint8 = np.clip(img, 0, 255).astype(np.uint8)
    else:
        img_uint8 = img
    
    # æ·»åŠ 1000åƒç´ é»‘è‰²è¾¹æ¡†ï¼ˆå®Œå…¨å¤ç°å‚è€ƒä»£ç ï¼‰
    img_padded = cv2.copyMakeBorder(
        img_uint8, 1000, 1000, 1000, 1000,
        cv2.BORDER_CONSTANT, value=0
    )
    
    # ä»¥(0,0)ä¸ºä¸­å¿ƒæ—‹è½¬ï¼ˆå®Œå…¨å¤ç°å‚è€ƒä»£ç ï¼‰
    center = (0, 0)
    rotation_matrix = cv2.getRotationMatrix2D(center, rotation_angle, 1.0)
    
    # æ‰§è¡Œæ—‹è½¬ï¼ˆå®Œå…¨å¤ç°å‚è€ƒä»£ç çš„å‚æ•°ï¼‰
    rotated = cv2.warpAffine(
        img_padded, rotation_matrix, (-1, -1),
        flags=cv2.INTER_LINEAR,
        borderMode=cv2.BORDER_CONSTANT,
        borderValue=0
    )
    
    # è½¬å› float32 ç”¨äºåç»­å¤„ç†
    return rotated.astype(np.float32)

# ---------- è¯»å›¾è½¬ç°åº¦ ----------
def to_gray(img):
    img = img.astype(np.float32)
    if img.ndim == 3:
        return img[:, :, 0]  # ç›´æ¥å– R é€šé“
    elif img.ndim == 2:
        return img
    else:
        raise ValueError("æ— æ•ˆå›¾åƒç»´åº¦")

# ---------- é«˜æ–¯æ‹Ÿåˆå‡½æ•° ----------
def gauss_1d(x, A, mu, sigma, B):
    return A * np.exp(-0.5 * ((x - mu) / sigma) ** 2) + B

def fit_gauss_center(line):
    x = np.arange(len(line), dtype=float)
    try:
        mu0 = np.sum(x * line) / np.sum(line)
        A0 = line.max() - line.min()
        B0 = line.min()
        p0 = [A0, mu0, 2.0, B0]
        popt, _ = curve_fit(gauss_1d, x, line, p0=p0, maxfev=1000)
        return popt[1]
    except (RuntimeError, ValueError):
        if gauss_fallback:
            return center_of_mass(line)[0]
        else:
            return np.nan

# ---------- è‡ªåŠ¨å¤šé¡¹å¼é˜¶æ•°é€‰æ‹© ----------
def fit_order(z, y, max_order=3, thresh=0.05):
    valid = ~np.isnan(y)
    if not np.any(valid):
        return 1
    z, y = z[valid], y[valid]
    if len(z) < 2:
        return 1
    
    best_deg = 1
    prev_res = np.std(y - Polynomial.fit(z, y, 1)(z))
    
    for deg in range(2, min(max_order + 1, len(z))):
        p = Polynomial.fit(z, y, deg)
        res = np.std(y - p(z))
        if prev_res - res < thresh:
            break
        prev_res = res
        best_deg = deg
    return best_deg

# ==================== ä¸»æµç¨‹ ====================

# 1. è¯»å–å¹¶æ—‹è½¬æ ‡å®šå›¾åƒï¼ˆå®Œå…¨å¤ç°å‚è€ƒä»£ç æ–¹å¼ï¼‰
print("æ­£åœ¨åŠ è½½å¹¶æ—‹è½¬æ ‡å®šå›¾åƒ...")
os.chdir(calib_dir)
calib_files = sorted(glob.glob('*.bmp'))

rotated_imgs = []
for f in calib_files:
    img = to_gray(imageio.imread(f))
    # å®Œå…¨æŒ‰ç…§å‚è€ƒä»£ç çš„æ–¹å¼æ—‹è½¬
    img_rotated = rotate_image_like_reference(img)
    rotated_imgs.append(img_rotated)

imgs = np.stack(rotated_imgs)
H, W = imgs.shape[1], imgs.shape[2]
print(f"âœ… æ ‡å®šå›¾åƒå·²åŠ è½½å¹¶æ—‹è½¬ï¼Œå½¢çŠ¶: {imgs.shape}")

# 2. æå–å‚è€ƒå¸§äº®ç‚¹
ref_img = imgs[0]  # ç¬¬0å¸§ä½œä¸ºå‚è€ƒï¼ˆæœ€é«˜é«˜åº¦ï¼‰
coords = peak_local_max(ref_img, min_distance=20, threshold_abs=50)
N = coords.shape[0]
print(f"ğŸ” æ£€æµ‹åˆ° {N} ä¸ªæœ‰æ•ˆå…‰æ–‘")

# 3. åˆå§‹åŒ–å³°å€¼ä½ç½®æ•°ç»„
peaks = np.full((N, 26), np.nan, dtype=np.float32)

# 4. å¤„ç†å‚è€ƒå¸§ï¼ˆç¬¬0å¸§ï¼‰- è®¡ç®—äºšåƒç´  X å’Œ Y
print("æ­£åœ¨å¤„ç†å‚è€ƒå¸§...")
subpixel_coords = np.full((N, 2), np.nan, dtype=np.float32)

for k in range(N):
    y0, x0 = coords[k]
    y1 = max(int(y0) - roi_radius, 0)
    y2 = min(int(y0) + roi_radius + 1, H)
    x1 = max(int(x0) - roi_radius, 0)
    x2 = min(int(x0) + roi_radius + 1, W)
    roi = imgs[0, y1:y2, x1:x2]
    
    if roi.size > 0 and roi.sum() > 1e-3:
        proj_x = roi.sum(axis=0)
        proj_y = roi.sum(axis=1)
        
        dx = fit_gauss_center(proj_x)
        dy = fit_gauss_center(proj_y)
        
        subpixel_x = x1 + dx
        subpixel_y = y1 + dy
        
        subpixel_coords[k] = [subpixel_x, subpixel_y]
        peaks[k, 0] = subpixel_y

# 5. å‘åè¿½è¸ªï¼ˆ1 â†’ 25ï¼‰
print("æ­£åœ¨å‘åè¿½è¸ª (1â†’25)...")
for i in range(1, 26):
    for k in range(N):
        if np.isnan(peaks[k, i-1]) or np.isnan(subpixel_coords[k, 0]):
            continue
            
        y_last = peaks[k, i-1] - 2      # äºšåƒç´  Y
        x_last = subpixel_coords[k, 0]   # äºšåƒç´  X
        
        y1 = max(int(y_last) - roi_radius, 0)
        y2 = min(int(y_last) + roi_radius + 1, H)
        x1 = max(int(x_last) - roi_radius, 0)
        x2 = min(int(x_last) + roi_radius + 1, W)
        
        roi = imgs[i, y1:y2, x1:x2]
        if roi.size > 0 and roi.sum() > 1e-3:
            proj_y = roi.sum(axis=1)
            dy = fit_gauss_center(proj_y)
            peaks[k, i] = y1 + dy

# 6. å¤šé¡¹å¼æ‹Ÿåˆ
print("æ­£åœ¨æ‹Ÿåˆæ ‡å®šæ›²çº¿...")
coeffs = []
orders = np.empty(N, dtype=int)
for k in range(N):
    deg = fit_order(heights_mm, peaks[k])
    p = Polynomial.fit(heights_mm, peaks[k], deg)
    coeffs.append(p.convert().coef[::-1])
    orders[k] = deg

# 7. ä¿å­˜ç»“æœ
print("æ­£åœ¨ä¿å­˜æ ‡å®šè¡¨...")
coeffs_np = np.empty(len(coeffs), dtype=object)
coeffs_np[:] = coeffs

np.savez('calib_table_final.npz',
         coeffs=coeffs_np,
         orders=orders,
         x0=subpixel_coords[:, 0],
         y0=subpixel_coords[:, 1],
         heights=heights_mm,
         peaks=peaks,
         N=N,
         rotation_angle=rotation_angle)

# 8. æŠ¥å‘Šç»“æœ
miss = np.isnan(peaks).sum(axis=1)
bad_spots = np.sum(miss > 0)
print("\n" + "="*50)
print("âœ… æ ‡å®šå®Œæˆï¼")
print(f"â€¢ æ€»å…‰æ–‘æ•°: {N}")
print(f"â€¢ å­˜åœ¨ä¸¢å¤±å¸§çš„å…‰æ–‘æ•°: {bad_spots}")
if bad_spots > 0:
    print(f"  ï¼ˆå»ºè®®æ£€æŸ¥é˜ˆå€¼æˆ–å›¾åƒè´¨é‡ï¼‰")
print(f"â€¢ æ ‡å®šæ–‡ä»¶å·²ä¿å­˜ä¸º: calib_table_final.npz")
print("="*50)
