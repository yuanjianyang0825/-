# -*- coding: utf-8 -*-
"""
å…‰è°±å…±ç„¦æ ‡å®šéªŒè¯è„šæœ¬
- è¯»å– calib_table_final.npz
- å¯¹30å¼ æ ‡å®šå›¾åæ¨é«˜åº¦
- è®¡ç®—æ®‹å·®å¹¶è¯„ä¼°ç²¾åº¦
"""

import os, glob
import numpy as np
import imageio.v2 as imageio
import matplotlib.pyplot as plt
from numpy.polynomial import Polynomial

# ==================== é…ç½®åŒº ====================
calib_dir = r'C:\Users\10574\Desktop\æ ‡å®šå›¾'   # æ ‡å®šå›¾åƒè·¯å¾„
dark_dir  = r'C:\Users\10574\Desktop\æš—åœºå›¾'   # æš—åœºè·¯å¾„
calib_file = 'calib_table_final.npz'           # æ ‡å®šè¡¨æ–‡ä»¶å

# å·²çŸ¥çœŸå®é«˜åº¦ï¼ˆå¿…é¡»ä¸æ ‡å®šæ—¶ä¸€è‡´ï¼ï¼‰
true_heights = np.linspace(2.9, 0, 30)  # mm

# =================================================

# ---------- å®‰å…¨è¯»å›¾è½¬ç°åº¦ï¼ˆä¸æ ‡å®šè„šæœ¬ä¸€è‡´ï¼‰----------
def to_gray(img):
    img = img.astype(np.float32)
    if img.ndim == 3:
        if img.shape[2] == 4:
            img = img[:, :, :3]
        elif img.shape[2] != 3:
            raise ValueError(f"ä¸æ”¯æŒçš„é€šé“æ•°: {img.shape[2]}")
        return img @ [0.299, 0.587, 0.114]
    elif img.ndim == 2:
        return img
    else:
        raise ValueError("æ— æ•ˆå›¾åƒç»´åº¦")

# ---------- 1D è´¨å¿ƒå®šä½ï¼ˆä¸æ ‡å®šè„šæœ¬ä¸€è‡´ï¼‰----------
def get_peak_y(img, y0, x0, radius=9):
    H, W = img.shape
    y1 = max(int(y0) - radius, 0)
    y2 = min(int(y0) + radius + 1, H)
    x1 = max(int(x0) - radius, 0)
    x2 = min(int(x0) + radius + 1, W)
    roi = img[y1:y2, x1:x2]
    if roi.size == 0 or roi.sum() < 1e-3:
        return np.nan
    proj = roi.sum(axis=1)
    return y1 + np.sum(np.arange(len(proj)) * proj) / np.sum(proj)

# ==================== ä¸»æµç¨‹ ====================

# 1. åŠ è½½æ ‡å®šè¡¨
print("æ­£åœ¨åŠ è½½æ ‡å®šè¡¨...")
data = np.load(calib_file, allow_pickle=True)
coeffs = data['coeffs']
orders = data['orders']
x0 = data['x0']
y0 = data['y0']
N = data['N']
print(f"âœ… åŠ è½½ {N} ä¸ªå…‰æ–‘çš„æ ‡å®šæ›²çº¿")

# 2. è¯»å–æš—åœºèƒŒæ™¯
print("æ­£åœ¨åŠ è½½æš—åœºèƒŒæ™¯...")
os.chdir(dark_dir)
dark_files = sorted(glob.glob('*.bmp'))[:10]
bg_imgs = [to_gray(imageio.imread(f)) for f in dark_files]
bg_mean = np.mean(np.stack(bg_imgs), axis=0)

# 3. è¯»å–æ ‡å®šå›¾åƒ
print("æ­£åœ¨åŠ è½½æ ‡å®šå›¾åƒ...")
os.chdir(calib_dir)
calib_files = sorted(glob.glob('*.bmp'))
assert len(calib_files) == 30
imgs_raw = np.stack([to_gray(imageio.imread(f)) for f in calib_files])
imgs = np.clip(imgs_raw - bg_mean, 0, None)

# 4. åæ¨é«˜åº¦
print("æ­£åœ¨åæ¨é«˜åº¦...")
recovered_heights = np.full((N, 30), np.nan)

for i in range(30):
    img = imgs[i]
    for k in range(N):
        # è·å–å½“å‰å¸§çš„ y åæ ‡ï¼ˆä½¿ç”¨ä¸æ ‡å®šç›¸åŒçš„è´¨å¿ƒæ³•ï¼‰
        y_est = get_peak_y(img, y0[k], x0[k], radius=9)
        if np.isnan(y_est):
            continue
        
        # ä½¿ç”¨æ ‡å®šå¤šé¡¹å¼åæ¨é«˜åº¦
        # æ³¨æ„ï¼šPolynomial çš„ coef æ˜¯ [c0, c1, c2, ...] å¯¹åº” c0 + c1*x + c2*x^2 + ...
        p = Polynomial(coeffs[k][:orders[k]+1])  # æˆªæ–­åˆ°å®é™…é˜¶æ•°
        # ä½† Polynomial æ˜¯ y = f(z)ï¼Œæˆ‘ä»¬éœ€è¦ z = f^{-1}(y)
        # ç”±äºæ˜¯ä½é˜¶å¤šé¡¹å¼ï¼Œå¯ç”¨æ•°å€¼æ–¹æ³•æ±‚æ ¹
        
        # ç®€åŒ–æ–¹æ¡ˆï¼šå› ä¸ºé‡ç¨‹å°ï¼Œç”¨æŸ¥è¡¨+æ’å€¼ï¼ˆæ›´ç¨³å®šï¼‰
        # è¿™é‡Œæˆ‘ä»¬ç”¨ Polynomial çš„ roots æ–¹æ³•è¿‘ä¼¼ï¼ˆä»…é€‚ç”¨äºå•è°ƒå‡½æ•°ï¼‰
        # æ›´ç¨³å¥çš„åšæ³•ï¼šåœ¨æ ‡å®šæ—¶ä¿å­˜ (z, y) æŸ¥è¡¨ï¼Œæ­¤å¤„ç”¨æ’å€¼
        
        # âš ï¸ ä¸´æ—¶æ–¹æ¡ˆï¼šå‡è®¾æ ‡å®šæ›²çº¿å•è°ƒï¼Œç”¨ Polynomial.fit çš„é€†ï¼ˆä»…ç”¨äºéªŒè¯ï¼‰
        # å®é™…ç³»ç»Ÿä¸­å»ºè®®ä¿å­˜æŸ¥è¡¨æˆ–ä½¿ç”¨ Newton-Raphson
        try:
            # æ„é€ æ–¹ç¨‹ p(z) - y_est = 0
            coef = coeffs[k].copy()
            coef[0] -= y_est
            p_inv = Polynomial(coef)
            roots = p_inv.roots()
            # é€‰æ‹©å®æ•°æ ¹ä¸”åœ¨ [0, 2.9] èŒƒå›´å†…çš„
            real_roots = roots[np.isreal(roots)].real
            valid_roots = real_roots[(real_roots >= 0) & (real_roots <= 2.9)]
            if len(valid_roots) > 0:
                recovered_heights[k, i] = valid_roots[0]
            else:
                recovered_heights[k, i] = np.nan
        except:
            recovered_heights[k, i] = np.nan

# 5. è®¡ç®—æ®‹å·®
print("æ­£åœ¨è®¡ç®—æ®‹å·®...")
residuals = recovered_heights - true_heights  # å¹¿æ’­ (N,30) - (30,) â†’ (N,30)

# 6. è¯„ä¼°ç²¾åº¦
valid = ~np.isnan(residuals)
if not np.any(valid):
    print("âŒ æ— æœ‰æ•ˆæ•°æ®ï¼")
else:
    rms_error = np.sqrt(np.mean(residuals[valid]**2))
    max_error = np.max(np.abs(residuals[valid]))
    mean_abs_error = np.mean(np.abs(residuals[valid]))
    
    print("\n" + "="*50)
    print("ğŸ“Š æ ‡å®šéªŒè¯ç»“æœ")
    print("="*50)
    print(f"â€¢ æœ‰æ•ˆæ•°æ®ç‚¹: {np.sum(valid)} / {N*30}")
    print(f"â€¢ RMS è¯¯å·®: {rms_error:.4f} mm")
    print(f"â€¢ å¹³å‡ç»å¯¹è¯¯å·®: {mean_abs_error:.4f} mm")
    print(f"â€¢ æœ€å¤§è¯¯å·®: {max_error:.4f} mm")
    print(f"â€¢ å¯¹åº”åƒç´ è¯¯å·®: {rms_error * 100:.2f} åƒç´ ")  # å‡è®¾ 100 pixel/mm
    
    # 7. å¯è§†åŒ–ï¼ˆå¯é€‰ï¼‰
    plt.figure(figsize=(12, 5))
    
    plt.subplot(1, 2, 1)
    plt.hist(residuals[valid], bins=50, edgecolor='k')
    plt.title('æ®‹å·®åˆ†å¸ƒ')
    plt.xlabel('è¯¯å·® (mm)')
    plt.ylabel('é¢‘æ¬¡')
    plt.grid(True)
    
    plt.subplot(1, 2, 2)
    # éšæœºé€‰5ä¸ªå…‰æ–‘ç”»è¯¯å·®æ›²çº¿
    idxs = np.random.choice(N, 5, replace=False)
    for idx in idxs:
        plt.plot(true_heights, residuals[idx], 'o-', label=f'å…‰æ–‘{idx}')
    plt.title('å„å…‰æ–‘æ®‹å·® vs é«˜åº¦')
    plt.xlabel('çœŸå®é«˜åº¦ (mm)')
    plt.ylabel('æ®‹å·® (mm)')
    plt.legend()
    plt.grid(True)
    
    plt.tight_layout()
    plt.savefig('calibration_validation.png', dpi=150)
    plt.show()

print("\nâœ… éªŒè¯å®Œæˆï¼ç»“æœå·²ä¿å­˜ä¸º calibration_validation.png")
