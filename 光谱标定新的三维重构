# -*- coding: utf-8 -*-
"""
åŸºäº calib_table_final.npz çš„ä¸‰ç»´è¡¨é¢å½¢è²Œé‡æ„è„šæœ¬
- ä½¿ç”¨ç¬¬0å¸§æ ‡å®šåæ ‡ä½œä¸ºåŸºå‡†
- å…ˆXæœ€è¿‘é‚»åŒ¹é…ï¼Œå†YèŒƒå›´ç­›é€‰
- æ”¯æŒé«˜ç²¾åº¦äºšåƒç´ å®šä½
"""

import os
import numpy as np
import imageio.v2 as imageio
from skimage.feature import peak_local_max
from scipy.ndimage import center_of_mass
from scipy.optimize import curve_fit
from numpy.polynomial import Polynomial
import matplotlib.pyplot as plt
import open3d as o3d

# ==================== é…ç½®åŒº ====================
# å¾…æµ‹æ ·å“å›¾åƒè·¯å¾„
sample_img_path = r"C:\Users\A\Desktop\sample.bmp"  # â† ä¿®æ”¹ä¸ºä½ çš„æ ·å“å›¾åƒè·¯å¾„

# æ ‡å®šè¡¨è·¯å¾„
calib_file = r"C:\Users\A\Desktop\calib_table_final.npz"

# åŒ¹é…å‚æ•°
x_tolerance = 3    # Xæ–¹å‘å®¹å¿åº¦ï¼ˆåƒç´ ï¼‰
y_min_offset = 0   # Yæ–¹å‘æœ€å°åç§»ï¼ˆåƒç´ ï¼‰
y_max_offset = 100 # Yæ–¹å‘æœ€å¤§åç§»ï¼ˆåƒç´ ï¼‰

# ROIå‚æ•°
roi_radius = 9
gauss_fallback = True

# =================================================

# ---------- è¯»å›¾è½¬ç°åº¦ ----------
def to_gray(img):
    img = img.astype(np.float32)
    if img.ndim == 3:
        return img[:, :, 0]  # ç›´æ¥å– R é€šé“
    elif img.ndim == 2:
        return img
    else:
        raise ValueError("æ— æ•ˆå›¾åƒç»´åº¦")

# ---------- é«˜æ–¯æ‹Ÿåˆå‡½æ•° ----------
def gauss_1d(x, A, mu, sigma, B):
    return A * np.exp(-0.5 * ((x - mu) / sigma) ** 2) + B

def fit_gauss_center(line):
    x = np.arange(len(line), dtype=float)
    try:
        mu0 = np.sum(x * line) / np.sum(line)
        A0 = line.max() - line.min()
        B0 = line.min()
        p0 = [A0, mu0, 2.0, B0]
        popt, _ = curve_fit(gauss_1d, x, line, p0=p0, maxfev=1000)
        return popt[1]
    except (RuntimeError, ValueError):
        if gauss_fallback:
            return center_of_mass(line)[0]
        else:
            return np.nan

# ==================== ä¸»æµç¨‹ ====================

# 1. åŠ è½½æ ‡å®šæ•°æ®
print("æ­£åœ¨åŠ è½½æ ‡å®šæ•°æ®...")
calib_data = np.load(calib_file, allow_pickle=True)
x0_calib = calib_data['x0']      # äºšåƒç´  X åæ ‡
y0_calib = calib_data['y0']      # äºšåƒç´  Y åæ ‡
coeffs = calib_data['coeffs']    # å¤šé¡¹å¼ç³»æ•°
orders = calib_data['orders']    # å¤šé¡¹å¼é˜¶æ•°
heights_mm = calib_data['heights']  # æ ‡å®šé«˜åº¦
peaks = calib_data['peaks']      # æ‰€æœ‰å¸§çš„ Y ä½ç½®
N = calib_data['N'].item()

print(f"âœ… å·²åŠ è½½ {N} ä¸ªå…‰æ–‘çš„æ ‡å®šæ•°æ®")

# 2. åŠ è½½æ ·å“å›¾åƒ
print("æ­£åœ¨åŠ è½½æ ·å“å›¾åƒ...")
if not os.path.exists(sample_img_path):
    raise FileNotFoundError(f"âŒ æ‰¾ä¸åˆ°æ ·å“å›¾åƒ: {sample_img_path}")

sample_img = to_gray(imageio.imread(sample_img_path))
H, W = sample_img.shape
print(f"âœ… æ ·å“å›¾åƒå°ºå¯¸: {H} x {W}")

# 3. æ£€æµ‹æ ·å“å…‰æ–‘ç²—ç•¥ä½ç½®
print("æ­£åœ¨æ£€æµ‹æ ·å“å…‰æ–‘...")
sample_peaks = peak_local_max(
    sample_img,
    min_distance=20,
    threshold_abs=50
)

print(f"ğŸ” æ£€æµ‹åˆ° {len(sample_peaks)} ä¸ªå…‰æ–‘å€™é€‰ç‚¹")
if len(sample_peaks) == 0:
    raise ValueError("âš ï¸ æœªæ£€æµ‹åˆ°ä»»ä½•å…‰æ–‘ï¼Œè¯·æ£€æŸ¥å›¾åƒè´¨é‡æˆ–è°ƒæ•´ threshold_abs")

# 4. äºšåƒç´ ç²¾ç¡®å®šä½
print("æ­£åœ¨äºšåƒç´ ç²¾ç¡®å®šä½...")
sample_subpixel = np.full((len(sample_peaks), 2), np.nan, dtype=np.float32)

for i, (y_int, x_int) in enumerate(sample_peaks):
    y1 = max(int(y_int) - roi_radius, 0)
    y2 = min(int(y_int) + roi_radius + 1, H)
    x1 = max(int(x_int) - roi_radius, 0)
    x2 = min(int(x_int) + roi_radius + 1, W)
    
    roi = sample_img[y1:y2, x1:x2]
    if roi.size == 0 or roi.sum() < 1e-3:
        continue
    
    # è®¡ç®—äºšåƒç´ åæ ‡
    proj_x = roi.sum(axis=0)
    proj_y = roi.sum(axis=1)
    
    dx = fit_gauss_center(proj_x)
    dy = fit_gauss_center(proj_y)
    
    subpixel_x = x1 + dx
    subpixel_y = y1 + dy
    
    sample_subpixel[i] = [subpixel_x, subpixel_y]

# è¿‡æ»¤æ— æ•ˆç‚¹
valid_sample_mask = ~np.isnan(sample_subpixel[:, 0])
sample_subpixel_valid = sample_subpixel[valid_sample_mask]
print(f"âœ… æœ‰æ•ˆå…‰æ–‘æ•°: {len(sample_subpixel_valid)}")

# 5. åŒ¹é…æ ‡å®šå…‰æ–‘ï¼ˆå…ˆXåYï¼‰
print("æ­£åœ¨åŒ¹é…æ ‡å®šå…‰æ–‘...")
matches = -np.ones(len(sample_subpixel_valid), dtype=int)

for i, p in enumerate(sample_subpixel_valid):
    # è®¡ç®—ä¸æ‰€æœ‰æ ‡å®šå…‰æ–‘çš„å·®å€¼
    dx = p[0] - x0_calib
    dy = p[1] - y0_calib
    
    # åº”ç”¨åŒ¹é…æ¡ä»¶
    idx = np.where(
        (np.abs(dx) < x_tolerance) & 
        (dy >= y_min_offset) & 
        (dy <= y_max_offset)
    )
    
    if len(idx[0]) == 0:
        continue
    
    # åœ¨æ»¡è¶³æ¡ä»¶çš„å€™é€‰ä¸­é€‰æ‹© Y æœ€æ¥è¿‘çš„
    dy_candidates = dy[idx[0]]
    best_candidate_idx = idx[0][np.argmin(np.abs(dy_candidates))]
    matches[i] = best_candidate_idx

num_matched = np.sum(matches >= 0)
print(f"âœ… æˆåŠŸåŒ¹é… {num_matched} ä¸ªå…‰æ–‘")

# 6. åæ¨é«˜åº¦ Z
print("æ­£åœ¨åæ¨é«˜åº¦...")
z_heights = np.full(len(matches), np.nan)

for i, match_idx in enumerate(matches):
    if match_idx < 0:
        continue
    
    # è·å–å½“å‰æ ·å“å…‰æ–‘çš„ Y åæ ‡
    y_measured = sample_subpixel_valid[i][1]
    
    # ä½¿ç”¨å¯¹åº”çš„å¤šé¡¹å¼åæ¨é«˜åº¦
    coef = coeffs[match_idx]
    deg = orders[match_idx]
    
    # æ„å»ºå¤šé¡¹å¼ y = f(z)
    p = Polynomial(coef[::-1])  # coef æ˜¯ [c0, c1, c2, ...] å¯¹åº” c0 + c1*z + c2*z^2 + ...
    
    # æ•°å€¼æœç´¢æ³•æ±‚è§£ z = f^{-1}(y)
    # åœ¨æ ‡å®šèŒƒå›´å†…æœç´¢
    z_search = np.linspace(heights_mm.min(), heights_mm.max(), 2000)
    y_pred = p(z_search)
    residuals = np.abs(y_pred - y_measured)
    best_z_idx = np.argmin(residuals)
    z_heights[i] = z_search[best_z_idx]

# 7. æå–æœ‰æ•ˆç»“æœ
valid_z_mask = ~np.isnan(z_heights)
x_coords = sample_subpixel_valid[valid_z_mask, 0]
y_coords = sample_subpixel_valid[valid_z_mask, 1]
z_coords = z_heights[valid_z_mask]

if len(z_coords) == 0:
    raise ValueError("âŒ æœªèƒ½åæ¨å‡ºä»»ä½•æœ‰æ•ˆé«˜åº¦ï¼")

print(f"ğŸ“Š æœ‰æ•ˆé«˜åº¦ç‚¹æ•°: {len(z_coords)}")
print(f"ğŸ“Š é«˜åº¦èŒƒå›´: {z_coords.min():.3f} ~ {z_coords.max():.3f} mm")

# 8. ç”Ÿæˆ3Dç‚¹äº‘
print("æ­£åœ¨ç”Ÿæˆ3Dç‚¹äº‘...")
points_3d = np.column_stack((x_coords, y_coords, z_coords))

# åˆ›å»ºOpen3Dç‚¹äº‘
pcd = o3d.geometry.PointCloud()
pcd.points = o3d.utility.Vector3dVector(points_3d)

# 9. å¯è§†åŒ–
print("æ­£åœ¨å¯è§†åŒ–3Dç‚¹äº‘...")
o3d.visualization.draw_geometries([pcd], window_name="Surface Reconstruction")

# 10. ä¿å­˜ç»“æœ
output_file = os.path.splitext(os.path.basename(sample_img_path))[0] + "_reconstruction.npz"
np.savez(output_file,
         x=x_coords,
         y=y_coords, 
         z=z_coords,
         points_3d=points_3d,
         params={
             'x_tolerance': x_tolerance,
             'y_min_offset': y_min_offset,
             'y_max_offset': y_max_offset,
             'matched_count': num_matched,
             'total_spots': N
         })

print(f"ğŸ‰ ä¸‰ç»´é‡æ„å®Œæˆï¼")
print(f"   æœ‰æ•ˆç‚¹æ•°: {len(z_coords)}")
print(f"   ç»“æœå·²ä¿å­˜è‡³: {output_file}")
