import numpy as np;
import cv2;
import matplotlib.pyplot as plt;
import os;
import glob;
from tqdm import tqdm;
import open3d as o3d;

### 提取文件-排序-读取第一张图并转灰度-黑色增长增宽图像-旋转图像并转BGR
all_bmp_files = glob.glob("./calib_2/*.bmp")
file_list = sorted(all_bmp_files, key=lambda p: int(os.path.splitext(os.path.basename(p))[0]))
deg = -3.05
raw = cv2.imread(file_list[0], cv2.IMREAD_GRAYSCALE)
raw = cv2.copyMakeBorder(raw,1000,1000,1000,1000,cv2.BORDER_CONSTANT)
center = (0,0)
rotate_matrix = cv2.getRotationMatrix2D(center, deg, 1)
raw = cv2.warpAffine(raw, rotate_matrix, (-1, -1))
raw = cv2.cvtColor(raw, cv2.COLOR_GRAY2BGR)

### 获取所有标定图的质心位置，并对应生成每一张图的质心标记图，生成一个在基图上的光斑色散图
points_channel = []
for img_file in file_list:
    points_this_img = []
    ok_blob_num = 0

    # 所有图像增大并旋转
    src = cv2.imread(img_file, cv2.IMREAD_GRAYSCALE)
    src = cv2.copyMakeBorder(src,1000,1000,1000,1000,cv2.BORDER_CONSTANT)
    center = (0,0)
    rotate_matrix = cv2.getRotationMatrix2D(center, deg, 1)
    src = cv2.warpAffine(src, rotate_matrix, (-1, -1))
 
    debug_img = cv2.cvtColor(src, cv2.COLOR_GRAY2BGR)     # 复制当前图像并转BGR，便于后面图像标记调试
    _, src = cv2.threshold(src, 30, 255, cv2.THRESH_BINARY)  # 图像二值化
    num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(src, connectivity=8)  # 对二值图像连通域分析，获取数量（包含背景1个），标签图，统计信息，质心位置
    for i in range(1, num_labels):
        area = stats[i, cv2.CC_STAT_AREA]
        if stats[i, cv2.CC_STAT_AREA] < 20 or stats[i, cv2.CC_STAT_AREA] > 200:
            continue
        x, y, w, h, area = stats[i]
        cx, cy = centroids[i]
        cv2.circle(debug_img, (int(cx), int(cy)), 1, (0, 255, 0), -1)  # 符合条件的光斑质心转换整数在调试图上用绿色圆点标记
        cv2.circle(raw, (int(cx), int(cy)), 1, (0, 255, 0), -1)  # 符合条件的光斑质心转换整数在所选的基图（即第一张图）上用绿色圆点标记
        points_this_img.append(np.array([cx, cy]))
        ok_blob_num += 1
    cv2.imwrite("./blob_pos/" + os.path.basename(img_file), debug_img);  # 每一张标定图生成一张绿圈图
    points_channel.append(np.array(points_this_img))  # 每张图的质心坐标加入到points_channel中
points_channel = np.array(points_channel)
cv2.imwrite("./blob_pos/raw.bmp", raw);  # 保存画上各标定图上质心圆点的基图

### 所有质心坐标的y坐标-15
for channel in points_channel:
    channel -= np.array([0,15])

==========================================================================================
import numpy as np;
import cv2;
import matplotlib.pyplot as plt
import os;
import glob;
from tqdm import tqdm;
import open3d as o3d;

points_re = []
file = "./recon/11.bmp"
# file = "./imgs3/10.bmp"

# 样品图同样读图按之前一样的方式处理
img_re = cv2.imread(file, cv2.IMREAD_GRAYSCALE)
img_re = cv2.copyMakeBorder(img_re,1000,1000,1000,1000,cv2.BORDER_CONSTANT)
center = (0,0)
rotate_matrix = cv2.getRotationMatrix2D(center, deg, 1)
img_re = cv2.warpAffine(img_re, rotate_matrix, (-1, -1))
thres = 35
_, bin_img = cv2.threshold(img_re, thres, 255, cv2.THRESH_BINARY)
num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(bin_img, connectivity=8)
img_re_color = cv2.cvtColor(img_re, cv2.COLOR_GRAY2BGR)
ok_blob_num = 0
for i in range(1, num_labels):
    area = stats[i, cv2.CC_STAT_AREA]
    if area < 20 or area > 200:
        continue
    ok_blob_num += 1
    x, y, w, h, area = stats[i]
    cx, cy = centroids[i]
    cv2.circle(img_re_color, (int(cx), int(cy)), 1, (0, 0, 255), -1)  # 样品图上画质心
    points_re.append(np.array([cx, cy]))  # points_re中存入每个质心坐标
print("ok_blob_num: ",ok_blob_num)
points_re = np.array(points_re)

## corresponding map
ref_points = points_channel[0]  # 取第0帧标定图
from scipy.spatial import cKDTree
pc = []

for p in points_re:
    dx = p[0] - ref_points[:,0]
    dy = p[1] - ref_points[:,1]
    
    idx = np.where((np.abs(dx) < 3)  & (dy >= 0) & (dy <= 100))
    if idx[0].size == 0:
        print("no corresponding point")
        continue
    
    closest_point = ref_points[idx[0]][0]
    x = closest_point[0] * 3.45 / 1000
    y = closest_point[1] * 3.45 / 1000
    z = (p[1] - closest_point[1]) / 75 * (-2.4)
    # print("(", p[0] - closest_point[0], p[1] - closest_point[1], ") depth >> ", z)
    pc.append([x, y, z])

pcd = o3d.geometry.PointCloud()
pcd.points = o3d.utility.Vector3dVector(pc)
o3d.visualization.draw_geometries([pcd], window_name="pc_window")
# o3d.io.write_point_cloud(os.path.basename(file).split(".")[0] + ".pcd", pcd)
============================================================================================
file_list = sorted(all_bmp_files, key=lambda p: int(os.path.splitext(os.path.basename(p))[0]))
deg = -3.05
raw = cv2.imread(file_list[0], cv2.IMREAD_GRAYSCALE)
raw = cv2.copyMakeBorder(raw,1000,1000,1000,1000,cv2.BORDER_CONSTANT)
center = (0,0)
rotate_matrix = cv2.getRotationMatrix2D(center, deg, 1)
raw = cv2.warpAffine(raw, rotate_matrix, (-1, -1))
raw = cv2.cvtColor(raw, cv2.COLOR_GRAY2BGR)
for cx,cy in np.vstack(points_channel):
    # cv2.circle(debug_img, (int(cx), int(cy)), 1, (0, 255, 0), -1)
    raw[int(cy), int(cx)] = (0,255,0)
for cx,cy in points_re:
    # cv2.circle(raw, (int(cx), int(cy)), 2, (0, 0, 255), -1)
    raw[int(cy), int(cx)] = (0,0,255)
cv2.imwrite("./raw.bmp",raw)
