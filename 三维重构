# -*- coding: utf-8 -*-
"""
åŸºäº calib_table_final.npz çš„ä¸‰ç»´é‡å»ºè„šæœ¬ï¼ˆé€‚é…æ—‹è½¬é˜µåˆ—ï¼‰
- ä½¿ç”¨æŸ¥è¡¨+æ’å€¼æ³•åæ¨é«˜åº¦
- è‡ªé€‚åº” X åŒ¹é…å®¹å¿åº¦ï¼ˆåŸºäºæœ€å°é—´è·ï¼‰
- é€‚ç”¨äºï¼šYæ–¹å‘ä½ç§»å¤§ã€XåŸºæœ¬ä¸å˜çš„æ—‹è½¬é’ˆå­”é˜µåˆ—ç³»ç»Ÿ
"""

import numpy as np
import imageio.v2 as imageio
import matplotlib.pyplot as plt
from scipy.interpolate import griddata, interp1d
from skimage.feature import peak_local_max
from scipy.ndimage import center_of_mass
from scipy.optimize import curve_fit
import os

# ==================== é…ç½®åŒº ====================
sample_img_path = r'C:\Users\10574\Desktop\æ ·å“å›¾\sample.bmp'  # â† ä¿®æ”¹ä¸ºä½ çš„æ ·å“å›¾åƒè·¯å¾„
calib_file = r'C:\Users\10574\Desktop\calib_table_final.npz'   # æ ‡å®šè¡¨è·¯å¾„
dark_dir = r'C:\Users\10574\Desktop\æš—åœºå›¾'                   # æš—åœºå›¾è·¯å¾„

# =================================================

# ---------- è¯»å›¾è½¬ç°åº¦ ----------
def to_gray(img):
    img = img.astype(np.float32)
    if img.ndim == 3:
        return img[:, :, 0]  # ç›´æ¥å– R é€šé“ï¼ˆç­‰äº G=Bï¼‰
    elif img.ndim == 2:
        return img
    else:
        raise ValueError("æ— æ•ˆå›¾åƒç»´åº¦")

# ---------- é«˜æ–¯æ‹Ÿåˆå‡½æ•° ----------
def gauss_1d(x, A, mu, sigma, B):
    return A * np.exp(-0.5 * ((x - mu) / sigma) ** 2) + B

def gauss_center_1d(line):
    x = np.arange(len(line), dtype=float)
    try:
        A0 = line.max() - line.min()
        mu0 = (line * x).sum() / line.sum()
        sig0 = 2.0
        B0 = line.min()
        popt, _ = curve_fit(gauss_1d, x, line, p0=[A0, mu0, sig0, B0], maxfev=1000)
        return popt[1]
    except (RuntimeError, ValueError):
        return (line * x).sum() / line.sum()

# ==================== ä¸»æµç¨‹ ====================

# 1. åŠ è½½æ ‡å®šæ•°æ®
print("æ­£åœ¨åŠ è½½æ ‡å®šæ•°æ®...")
calib = np.load(calib_file, allow_pickle=True)
x0_calib = calib['x0']          # å‚è€ƒå¸§ X åæ ‡
y0_calib = calib['y0']          # å‚è€ƒå¸§ Y åæ ‡
peaks = calib['peaks']          # (N, 30) æ‰€æœ‰å¸§çš„ Y ä½ç½®
heights = calib['heights']      # (30,) æ ‡å®šé«˜åº¦
N = calib['N'].item()
print(f"âœ… å·²åŠ è½½ {N} ä¸ªå…‰æ–‘çš„æ ‡å®šæ•°æ®")

# 2. æ„å»ºåå‘æ’å€¼å‡½æ•°ï¼ˆz = f(y)ï¼‰
print("æ­£åœ¨æ„å»ºé«˜åº¦åæ¨å‡½æ•°...")
interp_funcs = []
for k in range(N):
    y_vals = peaks[k]
    valid = ~np.isnan(y_vals)
    if np.sum(valid) < 2:
        interp_funcs.append(None)
    else:
        # ç¡®ä¿ y å•è°ƒï¼ˆå…‰è°±å…±ç„¦åº”æ»¡è¶³ï¼‰
        y_clean = y_vals[valid]
        z_clean = heights[valid]
        sort_idx = np.argsort(y_clean)
        y_clean = y_clean[sort_idx]
        z_clean = z_clean[sort_idx]
        # ä½¿ç”¨ cubic æ’å€¼ï¼Œå¤–æ¨ç”¨æœ€è¿‘å€¼
        f = interp1d(y_clean, z_clean, kind='cubic', fill_value="extrapolate")
        interp_funcs.append(f)

# 3. åŠ è½½æš—åœºèƒŒæ™¯
print("æ­£åœ¨åŠ è½½æš—åœºèƒŒæ™¯...")
dark_files = [os.path.join(dark_dir, f) for f in os.listdir(dark_dir) if f.endswith('.bmp')][:10]
bg_imgs = [to_gray(imageio.imread(f)) for f in dark_files]
bg_mean = np.mean(np.stack(bg_imgs), axis=0)

# 4. åŠ è½½æ ·å“å›¾åƒ
print("æ­£åœ¨åŠ è½½æ ·å“å›¾åƒ...")
if not os.path.exists(sample_img_path):
    raise FileNotFoundError(f"âŒ æ‰¾ä¸åˆ°å›¾åƒ: {sample_img_path}")
sample_img = to_gray(imageio.imread(sample_img_path))
img = np.clip(sample_img - bg_mean, 0, None)
print(f"âœ… å›¾åƒå°ºå¯¸: {img.shape}")

# 5. æ£€æµ‹å…‰æ–‘ç²—ç•¥ä½ç½®
peaks_new = peak_local_max(
    img,
    min_distance=20,
    threshold_abs=50  # èƒŒæ™¯æ‰£é™¤åå¯é™ä½é˜ˆå€¼
)
print(f"ğŸ” æ£€æµ‹åˆ° {len(peaks_new)} ä¸ªå…‰æ–‘å€™é€‰ç‚¹")

if len(peaks_new) == 0:
    raise ValueError("âš ï¸ æœªæ£€æµ‹åˆ°ä»»ä½•å…‰æ–‘ï¼Œè¯·æ£€æŸ¥å›¾åƒè´¨é‡")

# 6. äºšåƒç´ ç²¾ç¡®å®šä½ Y
radius = 9
y_subpix = np.zeros(len(peaks_new))

for i, (y_int, x_int) in enumerate(peaks_new):
    y1 = max(int(y_int) - radius, 0)
    y2 = int(y_int) + radius + 1
    x1 = max(int(x_int) - radius, 0)
    x2 = int(x_int) + radius + 1
    roi = img[y1:y2, x1:x2]
    
    if roi.size == 0 or roi.sum() < 1e-3:
        y_subpix[i] = np.nan
        continue
    
    proj = roi.sum(axis=1)
    dy = gauss_center_1d(proj)
    y_subpix[i] = y1 + dy

new_x = peaks_new[:, 1]        # æ£€æµ‹åˆ°çš„ X
new_y = peaks_new[:, 0]        # æ£€æµ‹åˆ°çš„ Yï¼ˆæ•´åƒç´ ï¼Œç”¨äºæ˜¾ç¤ºï¼‰
y_measured = y_subpix          # äºšåƒç´  Y

# 7. è‡ªé€‚åº” X åŒ¹é…å®¹å¿åº¦ï¼ˆé’ˆå¯¹æ—‹è½¬é˜µåˆ—ï¼‰
sorted_x = np.sort(x0_calib)
x_diffs = np.diff(sorted_x)
x_min_spacing = np.min(x_diffs)
# å®‰å…¨ä¸‹é™ï¼šé¿å…è¿‡å°
x_min_spacing = max(x_min_spacing, 5.0)
x_tolerance = x_min_spacing * 0.8  # 0.8 æ˜¯ç»éªŒæ¯”ä¾‹

print(f"ğŸ“Š X æœ€å°é—´è·: {x_min_spacing:.1f} åƒç´ ")
print(f"ğŸ“Š X åŒ¹é…å®¹å¿åº¦: {x_tolerance:.1f} åƒç´ ")

# 8. ä¸¤çº§åŒ¹é…ï¼šå…ˆ X è¿‘ â†’ å† Y æœ€è¿‘
matches = -np.ones(len(new_x), dtype=int)
used_calib_indices = set()  # é˜²æ­¢å¤šå¯¹ä¸€åŒ¹é…

for i in range(len(new_x)):
    xi = new_x[i]
    yi = y_measured[i]
    if np.isnan(yi):
        continue

    # Step 1: æ‰¾ X åœ¨å®¹å¿èŒƒå›´å†…çš„å€™é€‰
    candidate_mask = (x0_calib >= xi - x_tolerance) & (x0_calib <= xi + x_tolerance)
    candidate_indices = np.where(candidate_mask)[0]
    
    if len(candidate_indices) == 0:
        continue

    # Step 2: åœ¨å€™é€‰ä¸­æ‰¾ Y æœ€æ¥è¿‘çš„
    y0_candidates = y0_calib[candidate_indices]
    dy = np.abs(y0_candidates - yi)
    best_idx_in_candidates = np.argmin(dy)
    matched_k = candidate_indices[best_idx_in_candidates]

    # é˜²æ­¢é‡å¤åŒ¹é…
    if matched_k in used_calib_indices:
        continue
        
    matches[i] = matched_k
    used_calib_indices.add(matched_k)

num_matched = np.sum(matches >= 0)
print(f"âœ… æˆåŠŸåŒ¹é… {num_matched} ä¸ªå…‰æ–‘")

# 9. è§£ç®—é«˜åº¦ Zï¼ˆä½¿ç”¨æ’å€¼å‡½æ•°ï¼‰
Z_heights = np.full(len(matches), np.nan)

for i, match_idx in enumerate(matches):
    if match_idx < 0 or np.isnan(y_measured[i]):
        continue
    if interp_funcs[match_idx] is not None:
        try:
            Z_heights[i] = interp_funcs[match_idx](y_measured[i])
        except:
            Z_heights[i] = np.nan

# 10. æå–æœ‰æ•ˆæ•°æ®
valid_mask = ~np.isnan(Z_heights)
x_coords = new_x[valid_mask].astype(int)
y_coords = new_y[valid_mask].astype(int)
z_values = Z_heights[valid_mask]

if len(z_values) == 0:
    raise ValueError("âŒ æœªèƒ½è§£ç®—å‡ºä»»ä½•æœ‰æ•ˆé«˜åº¦ï¼")

print(f"ğŸ“Š æœ‰æ•ˆé«˜åº¦ç‚¹æ•°: {len(z_values)}")
print(f"ğŸ“Š é«˜åº¦èŒƒå›´: {z_values.min():.3f} ~ {z_values.max():.3f} mm")

# 11. æ’å€¼ç”Ÿæˆè¿ç»­é«˜åº¦å›¾
if len(z_values) > 3:  # è‡³å°‘4ç‚¹æ‰èƒ½cubicæ’å€¼
    xi_grid = np.linspace(x_coords.min(), x_coords.max(), 500)
    yi_grid = np.linspace(y_coords.min(), y_coords.max(), 500)
    Xi, Yi = np.meshgrid(xi_grid, yi_grid)
    
    Zi = griddata(
        points=(x_coords, y_coords),
        values=z_values,
        xi=(Xi, Yi),
        method='cubic',
        fill_value=np.nan
    )
else:
    Zi = None

# 12. å¯è§†åŒ–
plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False

fig = plt.figure(figsize=(14, 10))

# åŸå§‹å›¾åƒ + æ£€æµ‹ç‚¹
plt.subplot(2, 2, 1)
plt.imshow(img, cmap='gray')
plt.plot(x_coords, y_coords, 'r.', markersize=2, alpha=0.8)
plt.title("æ£€æµ‹åˆ°çš„å…‰æ–‘ä½ç½®")
plt.axis('off')

# æ•£ç‚¹é«˜åº¦åˆ†å¸ƒ
plt.subplot(2, 2, 2)
sc = plt.scatter(x_coords, y_coords, c=z_values, cmap='Spectral_r', s=10)
plt.colorbar(sc, label='é«˜åº¦ Z (mm)')
plt.title("å„å…‰æ–‘é«˜åº¦åˆ†å¸ƒ")
plt.axis('off')

# æ’å€¼å½¢è²Œ
if Zi is not None:
    plt.subplot(2, 1, 2)
    im = plt.imshow(Zi, cmap='Spectral_r', 
                    extent=[xi_grid.min(), xi_grid.max(), yi_grid.min(), yi_grid.max()],
                    origin='lower')
    plt.colorbar(im, label='é«˜åº¦ Z (mm)')
    plt.title("é‡å»ºçš„ä¸‰ç»´è¡¨é¢å½¢è²Œï¼ˆæ’å€¼åï¼‰")
    plt.xlabel("å›¾åƒ X åƒç´ ")
    plt.ylabel("å›¾åƒ Y åƒç´ ")

plt.tight_layout()
plt.show()

# 13. ä¿å­˜ç»“æœ
save_data = {
    'x': x_coords,
    'y': y_coords,
    'z': z_values,
    'params': {
        'x_tolerance': x_tolerance,
        'x_min_spacing': x_min_spacing,
        'N_matched': num_matched,
        'N_total': N
    }
}
if Zi is not None:
    save_data.update({'Xi': Xi, 'Yi': Yi, 'Zi': Zi})

np.savez('reconstructed_3d_surface.npz', **save_data)
print("ğŸ‰ ä¸‰ç»´å½¢è²Œé‡å»ºå®Œæˆï¼")
print(f"   æ•°æ®å·²ä¿å­˜è‡³: reconstructed_3d_surface.npz")
