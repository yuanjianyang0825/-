"""
- é‡ç¨‹ï¼š0â€“2.5 mmï¼Œ26 å¼ ç­‰é—´éš”é«˜åº¦å›¾åƒ
- æ”¹è¿›ç‚¹ï¼šåŒè½´åŠ¨æ€è¿½è¸ªï¼Œå»é™¤ç¡¬ç¼–ç ä½ç§»é¢„æµ‹
"""

import os, glob
import numpy as np
import imageio.v2 as imageio
from skimage.feature import peak_local_max
from scipy.optimize import curve_fit
from numpy.polynomial import Polynomial

# ==================== é…ç½®åŒº ====================
# è·¯å¾„é…ç½®ï¼ˆè¯·æŒ‰å®é™…ä¿®æ”¹ï¼‰
calib_dir = r"C:\Users\A\Desktop\biaoding"   

# æ ‡å®šå‚æ•°
# æ³¨æ„ï¼šä½ æ˜¯ä» 2.5mm é™åˆ° 0mm è¿˜æ˜¯ 0mm å‡åˆ° 2.5mmï¼Ÿ
# ä½ çš„æ–‡ä»¶åå¦‚æœæ˜¯ 1.bmp, 2.bmp... é€šå¸¸ 1 ä»£è¡¨èµ·å§‹ä½ç½®ã€‚
# å‡è®¾ 1.bmp å¯¹åº” 2.5mm (æ ¹æ®ä½ ä¹‹å‰çš„ä»£ç )ï¼Œå¦‚æœåäº†è¯·ä¿®æ”¹è¿™é‡Œã€‚
heights_mm = np.linspace(2.5, 0, 26)  

roi_radius = 12                       # ç¨å¾®åŠ å¤§ä¸€ç‚¹åŠå¾„ï¼Œé˜²æ­¢è·‘ä¸¢
gauss_fallback = True                 # é«˜æ–¯æ‹Ÿåˆå¤±è´¥æ—¶å›é€€åˆ°é‡å¿ƒæ³•

# =================================================

# ---------- è¯»å›¾è½¬ç°åº¦ ----------
def to_gray(img):
    if img.ndim == 2: return img.astype(np.float32)
    return img[:, :, 0].astype(np.float32)

# ---------- é«˜æ–¯æ‹Ÿåˆå‡½æ•° ----------
def gauss_1d(x, A, mu, sigma, B):
    return A * np.exp(-0.5 * ((x - mu) / sigma) ** 2) + B

def fit_gauss_center(line):
    x = np.arange(len(line), dtype=float)
    # ç®€å•çš„é‡å¿ƒæ³•ä½œä¸ºåˆå€¼ï¼Œæé«˜æ‹ŸåˆæˆåŠŸç‡
    total = np.sum(line)
    if total == 0: return np.nan
    mu0 = np.sum(x * line) / total
    
    A0 = line.max() - line.min()
    B0 = line.min()
    sigma0 = 2.0
    
    try:
        p0 = [A0, mu0, sigma0, B0]
        # bounds é™åˆ¶ mu åœ¨ ROI èŒƒå›´å†…ï¼Œé˜²æ­¢æ‹Ÿåˆé£å‡º
        popt, _ = curve_fit(gauss_1d, x, line, p0=p0, bounds=([0, 0, 0.1, -np.inf], [np.inf, len(line), len(line), np.inf]), maxfev=1000)
        return popt[1]
    except (RuntimeError, ValueError):
        if gauss_fallback:
            return mu0 # å›é€€åˆ°é‡å¿ƒ
        else:
            return np.nan

# ==================== ä¸»æµç¨‹ ====================

# 1. è¯»å–æ ‡å®šå›¾åƒ
print("æ­£åœ¨åŠ è½½æ ‡å®šå›¾åƒ...")
if not os.path.exists(calib_dir):
    raise FileNotFoundError(f"æ‰¾ä¸åˆ°æ–‡ä»¶å¤¹: {calib_dir}")

os.chdir(calib_dir)
# æŒ‰æ–‡ä»¶åæ•°å­—æ’åº
calib_files = sorted(glob.glob('*.bmp'), key=lambda p: int(os.path.splitext(os.path.basename(p))[0]))

if len(calib_files) != 26:
    print(f"è­¦å‘Š: æ‰¾åˆ°äº† {len(calib_files)} å¼ å›¾ï¼Œä½†é«˜åº¦å®šä¹‰äº† {len(heights_mm)} ä¸ªç‚¹ã€‚è¯·æ£€æŸ¥ï¼")

imgs = np.stack([to_gray(imageio.imread(f)) for f in calib_files])
H, W = imgs.shape[1], imgs.shape[2]
print(f"âœ… æ ‡å®šå›¾åƒå·²åŠ è½½ï¼Œå½¢çŠ¶: {imgs.shape}")

# 2. æå–å‚è€ƒå¸§äº®ç‚¹
# å»ºè®®ï¼šå¦‚æœç¬¬0å¸§å…‰æ–‘ä¸å…¨ï¼Œå¯ä»¥æ”¹ç”¨ç¬¬13å¸§(ä¸­é—´)åšå‚è€ƒï¼Œç„¶åå‘ä¸¤å¤´è¿½è¸ª
ref_idx = 0 
ref_img = imgs[ref_idx]

print("æ­£åœ¨æ£€æµ‹å…‰æ–‘...")
# min_distance å†³å®šäº†å…‰æ–‘çš„å¯†é›†ç¨‹åº¦ï¼Œæ ¹æ®ä½ çš„é¢é˜µå¯†åº¦è°ƒæ•´
coords = peak_local_max(ref_img, min_distance=15, threshold_abs=30) 
N = coords.shape[0]
print(f"ğŸ” æ£€æµ‹åˆ° {N} ä¸ªæœ‰æ•ˆå…‰æ–‘")

# 3. åˆå§‹åŒ–è½¨è¿¹æ•°ç»„
# tracks[k, i, 0] = y, tracks[k, i, 1] = x
tracks = np.full((N, len(calib_files), 2), np.nan, dtype=np.float32)

# 4. åˆå§‹åŒ–ç¬¬0å¸§ï¼ˆäºšåƒç´ ä¼˜åŒ–ï¼‰
print(f"æ­£åœ¨ä¼˜åŒ–ç¬¬ {ref_idx} å¸§åæ ‡...")
for k in range(N):
    y0_int, x0_int = coords[k]
    
    # ROI æˆªå–
    y1 = max(int(y0_int) - roi_radius, 0)
    y2 = min(int(y0_int) + roi_radius + 1, H)
    x1 = max(int(x0_int) - roi_radius, 0)
    x2 = min(int(x0_int) + roi_radius + 1, W)
    
    roi = ref_img[y1:y2, x1:x2]
    
    if roi.size > 0:
        dy = fit_gauss_center(roi.sum(axis=1)) # æŠ•å½±åˆ°Yè½´ç®—Yä¸­å¿ƒ
        dx = fit_gauss_center(roi.sum(axis=0)) # æŠ•å½±åˆ°Xè½´ç®—Xä¸­å¿ƒ
        
        if not np.isnan(dy) and not np.isnan(dx):
            tracks[k, ref_idx, 0] = y1 + dy # Abs Y
            tracks[k, ref_idx, 1] = x1 + dx # Abs X

# 5. åŠ¨æ€è¿½è¸ª (0 -> 25)
# å¦‚æœå‚è€ƒå¸§ä¸æ˜¯0ï¼Œè¿™é‡Œéœ€è¦å†™ä¸¤æ®µå¾ªç¯ï¼šä¸€æ®µå‘å‰ï¼Œä¸€æ®µå‘åã€‚
# è¿™é‡Œå‡è®¾å‚è€ƒå¸§æ˜¯0ï¼Œç›´æ¥å‘åè¿½è¸ª
print("æ­£åœ¨è¿›è¡ŒåŒè½´åŠ¨æ€è¿½è¸ª...")

for i in range(1, len(calib_files)):
    success_count = 0
    for k in range(N):
        # è·å–ä¸Šä¸€å¸§çš„åæ ‡
        last_y = tracks[k, i-1, 0]
        last_x = tracks[k, i-1, 1]
        
        if np.isnan(last_y) or np.isnan(last_x):
            continue # ä¸Šä¸€å¸§å°±ä¸¢äº†ï¼Œè¿™ä¸€å¸§æ”¾å¼ƒ
            
        # ä»¥â€œä¸Šä¸€å¸§â€çš„åæ ‡ä½œä¸ºâ€œå½“å‰å¸§â€çš„ROIä¸­å¿ƒ (ä¸åšç›²ç›®é¢„æµ‹ï¼Œåªåšæœ€è¿‘é‚»è·Ÿéš)
        # å› ä¸ºæ­¥é•¿åªæœ‰0.1mmï¼Œå…‰æ–‘ç§»åŠ¨é€šå¸¸<5åƒç´ ï¼Œè‚¯å®šåœ¨ROI(åŠå¾„12)å†…
        cy, cx = int(last_y), int(last_x)
        
        y1 = max(cy - roi_radius, 0)
        y2 = min(cy + roi_radius + 1, H)
        x1 = max(cx - roi_radius, 0)
        x2 = min(cx + roi_radius + 1, W)
        
        roi = imgs[i, y1:y2, x1:x2]
        
        if roi.size > 0 and roi.max() > 10: # ç¡®ä¿ROIé‡Œæœ‰äº®æ–‘
            dy = fit_gauss_center(roi.sum(axis=1))
            dx = fit_gauss_center(roi.sum(axis=0))
            
            if not np.isnan(dy) and not np.isnan(dx):
                tracks[k, i, 0] = y1 + dy # æ›´æ–° Y
                tracks[k, i, 1] = x1 + dx # æ›´æ–° X (è¿™ä¸€ç‚¹éå¸¸é‡è¦ï¼)
                success_count += 1
    
    # ç®€å•çš„è¿›åº¦æ¡
    if i % 5 == 0:
        print(f"  Frame {i}/{len(calib_files)-1}: è¿½è¸ªåˆ° {success_count}/{N} ä¸ªç‚¹")

# 6. å¤šé¡¹å¼æ‹Ÿåˆä¸ä¿å­˜
print("æ­£åœ¨æ‹Ÿåˆä¸ä¿å­˜...")
final_coeffs = []
final_ids = []

for k in range(N):
    # æå– Y åæ ‡ (é€šå¸¸å…‰è°±å…±ç„¦åªå…³å¿ƒ Y çš„ç§»åŠ¨)
    y_series = tracks[k, :, 0]
    valid_mask = ~np.isnan(y_series)
    
    if np.sum(valid_mask) > 15: # è‡³å°‘æœ‰15ä¸ªæœ‰æ•ˆç‚¹æ‰æ‹Ÿåˆ
        h_valid = heights_mm[valid_mask]
        y_valid = y_series[valid_mask]
        
        # æ‹Ÿåˆ Height = f(Pixel_Y) è¿˜æ˜¯ Pixel_Y = f(Height)?
        # æµ‹é‡æ—¶ï¼Œæˆ‘ä»¬æ˜¯å·²çŸ¥ Pixel_Y æ±‚ Heightã€‚
        # æ‰€ä»¥ç›´æ¥æ‹Ÿåˆ Height = f(Pixel_Y) æ¯”è¾ƒæ–¹ä¾¿åç»­ä½¿ç”¨ã€‚
        try:
            # 3æ¬¡å¤šé¡¹å¼æ‹Ÿåˆ: H = a*y^3 + b*y^2 + c*y + d
            c = np.polyfit(y_valid, h_valid, 3)
            
            # ä¿å­˜æ•°æ®: [Coeffs, (Original X, Original Y)]
            # è®°å½•ç¬¬0å¸§çš„åæ ‡ä½œä¸ºè¯¥ç‚¹çš„ ID
            final_coeffs.append(c)
            final_ids.append(tracks[k, 0, :]) 
        except:
            pass

np.savez('calib_data.npz', 
         coeffs=np.array(final_coeffs), 
         ids=np.array(final_ids),
         img_shape=(H, W))

print(f"\nâœ… å®Œæˆï¼æˆåŠŸæ ‡å®š {len(final_coeffs)} / {N} ä¸ªå…‰æ–‘ã€‚")
print("æ–‡ä»¶å·²ä¿å­˜ä¸º calib_data.npz")
