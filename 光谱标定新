"""
- é‡ç¨‹ï¼š0â€“2.9 mmï¼Œ30 å¼ ç­‰é—´éš”é«˜åº¦å›¾åƒ
"""

import os, glob
import numpy as np
import imageio.v2 as imageio
from skimage.feature import peak_local_max
from scipy.ndimage import center_of_mass
from scipy.optimize import curve_fit
from numpy.polynomial import Polynomial

# ==================== é…ç½®åŒº ====================
# è·¯å¾„é…ç½®ï¼ˆè¯·æŒ‰å®é™…ä¿®æ”¹ï¼‰
calib_dir = r'C:\Users\10574\Desktop\æ ‡å®šå›¾'   # 30å¼ ä¸åŒé«˜åº¦çš„æ ‡å®šå›¾åƒï¼ˆBMPï¼‰
dark_dir  = r'C:\Users\10574\Desktop\æš—åœºå›¾'   # æš—åœºå›¾åƒï¼ˆBMPï¼‰

# æ ‡å®šå‚æ•°
heights_mm = np.linspace(2.9, 0, 30)  # å·²çŸ¥é«˜åº¦ (mm)
roi_radius = 9                        # ROI åŠå¾„ï¼ˆåƒç´ ï¼‰
gauss_fallback = True                 # é«˜æ–¯æ‹Ÿåˆå¤±è´¥æ—¶å›é€€åˆ°è´¨å¿ƒ

# =================================================

# ---------- è¯»å›¾è½¬ç°åº¦ ----------
def to_gray(img):
    img = img.astype(np.float32)
    if img.ndim == 3:
        return img[:, :, 0]  # ç›´æ¥å– R é€šé“ï¼ˆç­‰äº G=Bï¼‰
    elif img.ndim == 2:
        return img
    else:
        raise ValueError("æ— æ•ˆå›¾åƒç»´åº¦")

# ---------- é«˜æ–¯æ‹Ÿåˆå‡½æ•° ----------
def gauss_1d(x, A, mu, sigma, B):
    return A * np.exp(-0.5 * ((x - mu) / sigma) ** 2) + B

def fit_gauss_center(line):
    x = np.arange(len(line), dtype=float)
    try:
        mu0 = np.sum(x * line) / np.sum(line)
        A0 = line.max() - line.min()
        B0 = line.min()
        p0 = [A0, mu0, 2.0, B0]
        popt, _ = curve_fit(gauss_1d, x, line, p0=p0, maxfev=1000)
        return popt[1]
    except (RuntimeError, ValueError):
        if gauss_fallback:
            return center_of_mass(line)[0]
        else:
            return np.nan

# ---------- è‡ªåŠ¨å¤šé¡¹å¼é˜¶æ•°é€‰æ‹© ----------
def fit_order(z, y, max_order=3, thresh=0.05):
    valid = ~np.isnan(y)
    if not np.any(valid):
        return 1
    z, y = z[valid], y[valid]
    if len(z) < 2:
        return 1
    
    best_deg = 1
    prev_res = np.std(y - Polynomial.fit(z, y, 1)(z))
    
    for deg in range(2, min(max_order + 1, len(z))):
        p = Polynomial.fit(z, y, deg)
        res = np.std(y - p(z))
        if prev_res - res < thresh:
            break
        prev_res = res
        best_deg = deg
    return best_deg

# ==================== ä¸»æµç¨‹ ====================

# 1. è¯»å–æš—åœºèƒŒæ™¯
print("æ­£åœ¨åŠ è½½æš—åœºå›¾åƒ...")
os.chdir(dark_dir)
dark_files = sorted(glob.glob('*.bmp'))
assert len(dark_files) >= 10, "æš—åœºå›¾ä¸è¶³10å¼ "
bg_imgs = [to_gray(imageio.imread(f)) for f in dark_files[:10]]
bg_mean = np.mean(np.stack(bg_imgs), axis=0)
print(f"âœ… èƒŒæ™¯å·²è®¡ç®—ï¼Œå½¢çŠ¶: {bg_mean.shape}")

# 2. è¯»å–æ ‡å®šå›¾åƒ
print("æ­£åœ¨åŠ è½½æ ‡å®šå›¾åƒ...")
os.chdir(calib_dir)
calib_files = sorted(glob.glob('*.bmp'))
assert len(calib_files) == 30, f"éœ€è¦30å¼ æ ‡å®šå›¾ï¼Œæ‰¾åˆ° {len(calib_files)} å¼ "
imgs_raw = np.stack([to_gray(imageio.imread(f)) for f in calib_files])
H, W = imgs_raw.shape[1], imgs_raw.shape[2]
imgs = np.clip(imgs_raw - bg_mean, 0, None)
print(f"âœ… æ ‡å®šå›¾åƒå·²åŠ è½½ï¼Œå½¢çŠ¶: {imgs.shape}")

# 3. æå–å‚è€ƒå¸§äº®ç‚¹
ref_img = imgs[14]  # ä¸­é—´é«˜åº¦ä½œä¸ºå‚è€ƒ
coords = peak_local_max(ref_img, min_distance=20, threshold_abs=50)
N = coords.shape[0]
print(f"ğŸ” æ£€æµ‹åˆ° {N} ä¸ªæœ‰æ•ˆå…‰æ–‘")

# 4. åˆå§‹åŒ–å³°å€¼ä½ç½®æ•°ç»„
peaks = np.full((N, 30), np.nan, dtype=np.float32)

# 5. å¤„ç†å‚è€ƒå¸§ï¼ˆç¬¬14å¸§ï¼‰
print("æ­£åœ¨å¤„ç†å‚è€ƒå¸§...")
for k in range(N):
    y0, x0 = coords[k]
    y1 = max(int(y0) - roi_radius, 0)
    y2 = min(int(y0) + roi_radius + 1, H)
    x1 = max(int(x0) - roi_radius, 0)
    x2 = min(int(x0) + roi_radius + 1, W)
    roi = imgs[14, y1:y2, x1:x2]
    if roi.size > 0 and roi.sum() > 1e-3:
        proj = roi.sum(axis=1)
        dy = fit_gauss_center(proj)
        peaks[k, 14] = y1 + dy

# 6. å‘å‰è¿½è¸ªï¼ˆ13 â†’ 0ï¼‰
print("æ­£åœ¨å‘å‰è¿½è¸ª (13â†’0)...")
for i in range(13, -1, -1):
    for k in range(N):
        if np.isnan(peaks[k, i+1]):
            continue
        y_last = peaks[k, i+1]
        x_last = coords[k, 1]
        y1 = max(int(y_last) - roi_radius, 0)
        y2 = min(int(y_last) + roi_radius + 1, H)
        x1 = max(int(x_last) - roi_radius, 0)
        x2 = min(int(x_last) + roi_radius + 1, W)
        roi = imgs[i, y1:y2, x1:x2]
        if roi.size > 0 and roi.sum() > 1e-3:
            proj = roi.sum(axis=1)
            dy = fit_gauss_center(proj)
            peaks[k, i] = y1 + dy

# 7. å‘åè¿½è¸ªï¼ˆ15 â†’ 29ï¼‰
print("æ­£åœ¨å‘åè¿½è¸ª (15â†’29)...")
for i in range(15, 30):
    for k in range(N):
        if np.isnan(peaks[k, i-1]):
            continue
        y_last = peaks[k, i-1]
        x_last = coords[k, 1]
        y1 = max(int(y_last) - roi_radius, 0)
        y2 = min(int(y_last) + roi_radius + 1, H)
        x1 = max(int(x_last) - roi_radius, 0)
        x2 = min(int(x_last) + roi_radius + 1, W)
        roi = imgs[i, y1:y2, x1:x2]
        if roi.size > 0 and roi.sum() > 1e-3:
            proj = roi.sum(axis=1)
            dy = fit_gauss_center(proj)
            peaks[k, i] = y1 + dy

# 8. å¤šé¡¹å¼æ‹Ÿåˆ
print("æ­£åœ¨æ‹Ÿåˆæ ‡å®šæ›²çº¿...")
coeffs = []
orders = np.empty(N, dtype=int)
for k in range(N):
    deg = fit_order(heights_mm, peaks[k])
    p = Polynomial.fit(heights_mm, peaks[k], deg)
    coeffs.append(p.convert().coef[::-1])  # ä½æ¬¡ â†’ é«˜æ¬¡
    orders[k] = deg

# 9. ä¿å­˜ç»“æœ
print("æ­£åœ¨ä¿å­˜æ ‡å®šè¡¨...")
coeffs_np = np.empty(len(coeffs), dtype=object)
coeffs_np[:] = coeffs

np.savez('calib_table_final.npz',
         coeffs=coeffs_np,
         orders=orders,
         x0=coords[:, 1],
         y0=coords[:, 0],
         heights=heights_mm,
         peaks=peaks,      # åŸå§‹å³°å€¼ä½ç½®ï¼ˆç”¨äºéªŒè¯ï¼‰
         N=N)

# 10. æŠ¥å‘Šç»“æœ
miss = np.isnan(peaks).sum(axis=1)
bad_spots = np.sum(miss > 0)
print("\n" + "="*50)
print("âœ… æ ‡å®šå®Œæˆï¼")
print(f"â€¢ æ€»å…‰æ–‘æ•°: {N}")
print(f"â€¢ å­˜åœ¨ä¸¢å¤±å¸§çš„å…‰æ–‘æ•°: {bad_spots}")
if bad_spots > 0:
    print(f"  ï¼ˆå»ºè®®æ£€æŸ¥é˜ˆå€¼æˆ–å›¾åƒè´¨é‡ï¼‰")
print(f"â€¢ æ ‡å®šæ–‡ä»¶å·²ä¿å­˜ä¸º: calib_table_final.npz")
print("="*50)
