"""
- é‡ç¨‹ï¼š0â€“2.5 mmï¼Œ26 å¼ ç­‰é—´éš”é«˜åº¦å›¾åƒ
"""

import os, glob
import numpy as np
import imageio.v2 as imageio
from skimage.feature import peak_local_max
from scipy.ndimage import center_of_mass
from scipy.optimize import curve_fit
from numpy.polynomial import Polynomial

# ==================== é…ç½®åŒº ====================
# è·¯å¾„é…ç½®ï¼ˆè¯·æŒ‰å®é™…ä¿®æ”¹ï¼‰
calib_dir = r"C:\Users\A\Desktop\biaoding"   # 26å¼ ä¸åŒé«˜åº¦çš„æ ‡å®šå›¾åƒï¼ˆBMPï¼‰

# æ ‡å®šå‚æ•°
heights_mm = np.linspace(2.5, 0, 26)  # å·²çŸ¥é«˜åº¦ (mm)
roi_radius = 9                        # ROI åŠå¾„ï¼ˆåƒç´ ï¼‰
gauss_fallback = True                 # é«˜æ–¯æ‹Ÿåˆå¤±è´¥æ—¶å›é€€åˆ°è´¨å¿ƒ

# =================================================

# ---------- è¯»å›¾è½¬ç°åº¦ ----------
def to_gray(img):
    img = img.astype(np.float32)
    return img[:, :, 0]  # ç›´æ¥å– R é€šé“ï¼ˆç­‰äº G=Bï¼‰

# ---------- é«˜æ–¯æ‹Ÿåˆå‡½æ•° ----------
def gauss_1d(x, A, mu, sigma, B):
    return A * np.exp(-0.5 * ((x - mu) / sigma) ** 2) + B

def fit_gauss_center(line):
    x = np.arange(len(line), dtype=float)
    try:
        mu0 = np.sum(x * line) / np.sum(line)
        A0 = line.max() - line.min()
        B0 = line.min()
        p0 = [A0, mu0, 2.0, B0]
        popt, _ = curve_fit(gauss_1d, x, line, p0=p0, maxfev=1000)
        return popt[1]
    except (RuntimeError, ValueError):
        if gauss_fallback:
            return center_of_mass(line)[0]
        else:
            return np.nan

# ---------- è‡ªåŠ¨å¤šé¡¹å¼é˜¶æ•°é€‰æ‹© ----------
def fit_order(z, y, max_order=3, thresh=0.05):
    valid = ~np.isnan(y)
    if not np.any(valid):
        return 1
    z, y = z[valid], y[valid]
    if len(z) < 2:
        return 1
    
    best_deg = 1
    prev_res = np.std(y - Polynomial.fit(z, y, 1)(z))
    
    for deg in range(2, min(max_order + 1, len(z))):
        p = Polynomial.fit(z, y, deg)
        res = np.std(y - p(z))
        if prev_res - res < thresh:
            break
        prev_res = res
        best_deg = deg
    return best_deg

# ==================== ä¸»æµç¨‹ ====================

# 1. è¯»å–æ ‡å®šå›¾åƒ
print("æ­£åœ¨åŠ è½½æ ‡å®šå›¾åƒ...")
os.chdir(calib_dir)
calib_files = sorted(glob.glob('*.bmp'), key=lambda p: int(os.path.splitext(os.path.basename(p))[0]))
imgs = np.stack([to_gray(imageio.imread(f)) for f in calib_files])
H, W = imgs.shape[1], imgs.shape[2]
print(f"âœ… æ ‡å®šå›¾åƒå·²åŠ è½½ï¼Œå½¢çŠ¶: {imgs.shape}")

# 2. æå–å‚è€ƒå¸§äº®ç‚¹
ref_img = imgs[0]  # ç¬¬0å¸§ä½œä¸ºå‚è€ƒ
coords = peak_local_max(ref_img, min_distance=20, threshold_abs=50)
N = coords.shape[0]
print(f"ğŸ” æ£€æµ‹åˆ° {N} ä¸ªæœ‰æ•ˆå…‰æ–‘")

# 3. åˆå§‹åŒ–å³°å€¼ä½ç½®æ•°ç»„
peaks = np.full((N, 26), np.nan, dtype=np.float32)

# 4. å¤„ç†å‚è€ƒå¸§ï¼ˆç¬¬0å¸§ï¼‰- è®¡ç®—äºšåƒç´  X å’Œ Y
print("æ­£åœ¨å¤„ç†å‚è€ƒå¸§...")
subpixel_coords = np.full((N, 2), np.nan, dtype=np.float32)  # å­˜å‚¨äºšåƒç´ åæ ‡

for k in range(N):
    y0, x0 = coords[k]  # æ•´åƒç´ åˆå§‹ä½ç½®
    y1 = max(int(y0) - roi_radius, 0)
    y2 = min(int(y0) + roi_radius + 1, H)
    x1 = max(int(x0) - roi_radius, 0)
    x2 = min(int(x0) + roi_radius + 1, W)
    roi = imgs[0, y1:y2, x1:x2]
    
    if roi.size > 0 and roi.sum() > 1e-3:
        # æ²¿ Y æ–¹å‘ç§¯åˆ†å¾—åˆ° X æ–¹å‘åˆ†å¸ƒ
        proj_x = roi.sum(axis=0)  # shape: (width,)
        # æ²¿ X æ–¹å‘ç§¯åˆ†å¾—åˆ° Y æ–¹å‘åˆ†å¸ƒ  
        proj_y = roi.sum(axis=1)  # shape: (height,)
        
        # è®¡ç®—äºšåƒç´ åæ ‡
        dx = fit_gauss_center(proj_x)  # X æ–¹å‘äºšåƒç´ åç§»
        dy = fit_gauss_center(proj_y)  # Y æ–¹å‘äºšåƒç´ åç§»
        
        subpixel_x = x1 + dx
        subpixel_y = y1 + dy
        
        subpixel_coords[k] = [subpixel_x, subpixel_y]
        peaks[k, 0] = subpixel_y  # ä¿å­˜äºšåƒç´  Y


# 5. å‘åè¿½è¸ªï¼ˆ1 â†’ 25ï¼‰
print("æ­£åœ¨å‘åè¿½è¸ª (1â†’25)...")
for i in range(1, 26):
    for k in range(N):
        if np.isnan(peaks[k, i-1]) or np.isnan(subpixel_coords[k, 0]):
            continue
            
        # ä½¿ç”¨äºšåƒç´ åæ ‡ä½œä¸º ROI ä¸­å¿ƒ
        y_last = peaks[k, i-1] - 2      # äºšåƒç´  Y
        x_last = subpixel_coords[k, 0]  # äºšåƒç´  X
        
        y1 = max(int(y_last) - roi_radius, 0)
        y2 = min(int(y_last) + roi_radius + 1, H)
        x1 = max(int(x_last) - roi_radius, 0)
        x2 = min(int(x_last) + roi_radius + 1, W)
        
        roi = imgs[i, y1:y2, x1:x2]
        if roi.size > 0 and roi.sum() > 1e-3:
            proj_y = roi.sum(axis=1)
            dy = fit_gauss_center(proj_y)
            peaks[k, i] = y1 + dy

# 6. å¤šé¡¹å¼æ‹Ÿåˆ
print("æ­£åœ¨æ‹Ÿåˆæ ‡å®šæ›²çº¿...")
coeffs = []
orders = np.empty(N, dtype=int)
for k in range(N):
    deg = fit_order(heights_mm, peaks[k])
    p = Polynomial.fit(heights_mm, peaks[k], deg)
    coeffs.append(p.convert().coef[::-1])  # ä½æ¬¡ â†’ é«˜æ¬¡
    orders[k] = deg

# 7. ä¿å­˜ç»“æœ
print("æ­£åœ¨ä¿å­˜æ ‡å®šè¡¨...")
coeffs_np = np.empty(len(coeffs), dtype=object)
coeffs_np[:] = coeffs

np.savez('calib_table_final.npz',
         coeffs=coeffs_np,
         orders=orders,
         x0=subpixel_coords[:, 0],  # âœ… äºšåƒç´  X
         y0=subpixel_coords[:, 1],  # âœ… äºšåƒç´  Y  
         heights=heights_mm,
         peaks=peaks,
         N=N)

# 8. æŠ¥å‘Šç»“æœ
miss = np.isnan(peaks).sum(axis=1)
bad_spots = np.sum(miss > 0)
print("\n" + "="*50)
print("âœ… æ ‡å®šå®Œæˆï¼")
print(f"â€¢ æ€»å…‰æ–‘æ•°: {N}")
print(f"â€¢ å­˜åœ¨ä¸¢å¤±å¸§çš„å…‰æ–‘æ•°: {bad_spots}")
if bad_spots > 0:
    print(f"  ï¼ˆå»ºè®®æ£€æŸ¥é˜ˆå€¼æˆ–å›¾åƒè´¨é‡ï¼‰")
print(f"â€¢ æ ‡å®šæ–‡ä»¶å·²ä¿å­˜ä¸º: calib_table_final.npz")
print("="*50)
